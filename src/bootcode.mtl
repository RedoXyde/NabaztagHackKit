// VLISP - Feb 06 - by Sylvain Huet
// Metal
// V16 : Nouveau Taichi d'Antoine Schmitt
// V17 : 25may07 : Nouvelles chor?graphies streaming d'Antoine Schmitt
// v17bis : 31may07 : Validation de la palette pour les messages
// v18 : 01june07 : Ouverture du micro à distance par romain
// v19 : july07 : Amélioration du RFID (son + lumière + suppression du 0000000) + Permet la reco meme lorsque le lapin dort
// v20 : Mise en commentaire de la fonction Key "RC" permettant l'ouverture à distance du micro (oui c'est une nouvelle version un peu inutile)
// v21 : AS 29aug07: Corrections bugs 195, 196, 197, 199, 202, 196

proto main 0;;

var NOMINAL;;

ifdef NOMINAL
{
var AUDIOLIB;;
var EARSLIB;;
var INFOLIB;;
var RECLIB;;
}

var HARDWARE=4;;
var DNSLOCAL=1597;;

proto buttoncheckevent 0;;

var gInteractiveApp = nil;;
proto interactiveNoteEarTouched 3;;

type Wifi=initW | gomasterW | masterW | gostationW _ | dhcpW _| stationW | reconnectW;;
var wifi;;

var netip="\0\0\0\0";;
var netmask="\255\255\255\0";;
var netgateway="\0\0\0\0";;
var netdns="\0\0\0\0";;

var mymac;;

var macbroadcast="\$ff\$ff\$ff\$ff\$ff\$ff";;
var ipbroadcast="\$ff\$ff\$ff\$ff";;

var master=0;;

var netip_empty="\0\0\0\0";;

var netip_master="\192\168\2\1";;
var netmask_master="\255\255\255\0";;
var netgateway_master="\192\168\0\1";;

var wifiscans;;

var IEEE80211_CRYPT_NONE=0;;
var IEEE80211_CRYPT_WEP64=1;;
var IEEE80211_CRYPT_WEP128=2;;
var IEEE80211_CRYPT_WPA=3;;
var IEEE80211_CRYPT_WPA_UNSUPPORTED=4;;

var IEEE80211_AUTH_OPEN=0;;
var IEEE80211_AUTH_SHARED=1;;

var FIRMWARE=0x010110;; // v16


// --------------- UTIL debut
//fun strcmp a b = vstrcmp a 0 b 0 nil;;
fun strstr s p i=strfind s i p 0 nil;;
fun itoanil l=if l==nil then '0'::nil else l;;
fun listlen l=if l==nil then 0 else 1+listlen tl l;;
fun listrem l x=if l!=nil then if x==hd l then tl l else (hd l)::listrem tl l x;;
fun slistlen l=	if l==nil then 0 else (strlen hd l)+slistlen tl l;;
fun listnth l i=if !i then hd l else if i>0 then listnth tl l i-1;;

fun listtostr l=
	let strnew listlen l -> s in
	let 0->i in
	(
		for p=l;p!=nil;tl p do
		(
			strset s i hd p;
			set i=i+1
		);
	s
	);;

fun atoibin2 val=itobin2 atoi val;;

fun countpattern s p i=
	let strstr s p i -> j in
	if j==nil then 0
	else 1+countpattern s p j+strlen p;;

fun strreplace2 sn s p v i id=
	if i<strlen s then
	let strstr s p i -> j in
	let if j==nil then strlen s else j -> k in
	(
		strcpy sn id s i k-i;
		if j!=nil then strcpy sn id+k-i v 0 nil;
		strreplace2 sn s p v k+strlen p id+k-i+strlen v
	);;

fun strreplace s p v=
	let countpattern s p 0 -> i in
	if !i then s
	else let strnew (strlen s) + ((strlen v)-(strlen p))*i -> sn in
	(
		strreplace2 sn s p v 0 0;
		sn
	);;


fun rev p q=if p==nil then q else rev tl p (hd p)::q;;

fun remfromlist l t= if l!=nil then if t==hd l then tl l else (hd l)::remfromlist tl l t;;

fun insert x l f=
	if l==nil then x::nil
	else let call f [x hd l] -> r in
	if r>0 then (hd l)::insert x tl l f
	else if r<0 then x::l
	else insert x tl l f;;

fun sort l f= if l!=nil then insert hd l sort tl l f f;;

fun select l a f= if l!=nil then let hd l-> x in if call f [x a] then x::select tl l a f else select tl l a f;;

fun conc p q=if p==nil then q else (hd p)::conc tl p q;;

fun random n= ((rand&255)*n)>>8;; // nombre entre 0 et n-1 inclus

fun _useparamip s i val j=
	if i<4 then
	let strstr val "." j -> k in
	(
		strset s i atoi strsub val j if k==nil then nil else k-j;
		_useparamip s i+1 val if k==nil then strlen val else k+1
	);;

fun useparamip val=
	let strnew 4 -> ip in
	(
		_useparamip ip 0 val 0;
		ip
	);;

fun webip ip=
	strcatlist (itoa strget ip 0)::"."::(itoa strget ip 1)::"."::(itoa strget ip 2)::"."::(itoa strget ip 3)::nil;;

fun _webmac key i=
	if i<strlen key then (ctoh strget key i)::if i+1<strlen key then ":"::_webmac key i+1 else _webmac key i+1;;

fun webmac key=strcatlist _webmac key 0;;

proto setleds 1;;

// ---------------- UTIL fin











// ################################################
// ##### LeftRotate 16bits // Octobre 2007 // Romain COCHET
// ################################################
var tmp;;
var val;;
fun leftrotate val nb_rot =
	let val.(0) -> valh in
	let val.(1) -> vall in (
		if nb_rot == 16 then (
			{vall valh}
		) else (
			if nb_rot > 16 then (
				// inversion de h et l, et on gère comme si c'était n-16.
				set tmp = valh;
				set valh = vall;
				set vall = tmp;
				set nb_rot = nb_rot - 16
			);
			{
				(valh << nb_rot) & 0xFFFF | (vall >> (16 - nb_rot))
				(vall << nb_rot) & 0xFFFF | (valh >> (16 - nb_rot))
			}
		)
	);;


fun MACecho src i0 ln=
	for i=0;i<6 do (Secho ctoh strget src i0+i; Secho ".");	if ln then Secholn "";
	src;;

fun SEQecho src i0 ln=
	for i=0;i<4 do (Secho ctoh strget src i0+i; Secho ".");	if ln then Secholn "";
	src;;

fun IPecho src i0 ln=
	for i=0;i<4 do (Iecho strget src i0+i; Secho ".");if ln then Secholn "";
	src;;

fun itoh4 i = strcatlist (ctoh i>>24)::(ctoh i>>16)::(ctoh i>>8)::(ctoh i)::nil;;

fun dump s=
	for i0=0;i0<strlen s;i0+16 do
	(
		Secho itoh4 i0;
		Secho " ";
		for i=0;i<16 do let strget s i0+i -> c in
		(
			Secho if c==nil then "  " else ctoh c;
			Secho " "
		);
		Secho " ";
		for i=0;i<16 do let strget s i0+i -> c in
		(
			Secho if c==nil then "  " else if c<32 then "." else ctoa c
		);
		Secholn ""
	);

	s;;

fun dumpscan l0=
	Secholn "## DUMPSCAN >>>>";
	for l=l0;l!=nil;tl l do
	let hd l->[ssid mac bssid rssi channel rateset encryption] in
	(
		Secho "## SCAN "; Secholn ssid;
		Secho "mac:"; MACecho mac 0 1;
		Secho "bssid:"; MACecho bssid 0 1;
		Secho "rssi:"; Iecholn rssi;
		Secho "channel:"; Iecholn channel;
		Secho "rateset:"; Iecholn rateset;
		Secho "encryption:"; Iecholn encryption
	);
	l0;;

// ------------- Config debut
var CONF_SERVERURL=0;;		//41
var CONF_NETDHCP=41;;		//1
var CONF_NETIP=42;;			//4
var CONF_NETMASK=46;;		//4
var CONF_NETGATEWAY=50;;	//4
var CONF_NETDNS=54;;		//4
var CONF_WIFISSID=58;;		//32
var CONF_WIFIAUTH=90;;		//1
var CONF_WIFICRYPT=91;;		//1
var CONF_WIFIKEY0=92;;		//64
var CONF_PROXYENABLE=156;;	//1
var CONF_PROXYIP=157;;		//4
var CONF_PROXYPORT=161;;	//2
var CONF_LOGIN=163;;		//6
var CONF_PWD=169;;			//6
var CONF_WIFIPMK=175;;		//32
var CONF_MAGIC=207;;		//1
var CONF_LENGTH=208;;

var conf;;

fun confSave=
	Secholn "## save configuration";
	dump conf;
	save conf 0 "conf.bin" 0 CONF_LENGTH;;

fun confInit=
	set conf=strnew CONF_LENGTH;
	load conf 0 "conf.bin" 0 CONF_LENGTH;
	dump conf;;

fun confGet i len= strsub conf i len;;

fun confGetbin i len= strsub conf i len;;

fun confGetstr i len=
	let strstr conf "\0" i -> j in
	strsub conf i (if j==nil then len else min len j-i);;

fun confSet i val len=
	strcpy conf i val 0 len;;

fun confSetbin i val len=strcpy conf i val 0 len;;

fun confSetstr i val len=
	let min strlen val len-1 -> len in
	(
		strcpy conf i val 0 len;
		strset conf i+len 0
	);;

fun webport s= ((strget s 0)<<8)+strget s 1;;

fun confGetWifissid=confGetstr CONF_WIFISSID 32;;
fun confGetWificrypt=strget confGet CONF_WIFICRYPT 1 0;;
fun confGetWifikey0=confGetstr CONF_WIFIKEY0 64;;
fun confGetWifiauth=strget confGet CONF_WIFIAUTH 1 0;;
fun confGetWifipmk=confGetbin CONF_WIFIPMK 32;;

fun confGetDhcp=strget confGet CONF_NETDHCP 1 0;;
fun confGetNetip=confGet CONF_NETIP 4;;
fun confGetNetmask=confGet CONF_NETMASK 4;;
fun confGetNetgateway=confGet CONF_NETGATEWAY 4;;
fun confGetNetdns=confGet CONF_NETDNS 4;;

fun confGetServerUrl=confGetstr CONF_SERVERURL 40;;
fun confGetLogin=confGet CONF_LOGIN 6;;
fun confGetPwd=confGet CONF_PWD 6;;

fun confGetProxy=strget confGet CONF_PROXYENABLE 1 0;;
fun confGetProxyip=confGet CONF_PROXYIP 4;;
fun confGetProxyport=webport confGet CONF_PROXYPORT 2;;

// ------------- Config fin

ifndef SIMU
{


// ------------- IP debut
fun strputchk s i w=
	strset s i ~(w>>8);
	strset s i+1 ~w;
	0;;

// ------------- IP fin

// ------------- ARP debut
var ARPREQ=1;;
var ARPANS=2;;

var larp;;
var larpreq;;

fun mkarp op ipsrc macdst ipdst=
	strcatlist
	"\$aa\$aa\$03\$00\$00\$00\$08\$06\$00\$01\$08\$00\$06\$04\$00"::(ctoa op)::
	mymac::
	netip::
	macdst::
	ipdst
	::nil;;

fun sendarp ip=
	netSend (mkarp ARPREQ netip macbroadcast ip) 0 nil macbroadcast 0 1;;


fun filterarpip l src =
	if l!=nil then let hd l->[ip _ _] in if !vstrcmp src 8+14 ip 0 4  then filterarpip tl l src
	else (hd l)::filterarpip tl l src;;

fun checkarp l src=
	if l!=nil then let hd l->[ip _ cb] in
	(
		if !vstrcmp src 8+14 ip 0 4 then
		let strsub src 8+8 6 -> mac in
		(
			Secho "found MAC target : "; MACecho mac 0 1;
			set larp=[ip mac]::larp;
			call cb [mac]
		);
		checkarp tl l src
	);;

fun cbnetarp src mac=
	Secho "<a";
	let strget src 8+7-> op in
	if op==1 then // req
	(
//		Secho "ask ";MACecho src 16+10 1; IPecho src 16+16 1;
		if !vstrcmp src 32 netip 0 4 then
			netSend (mkarp ARPANS netip strsub src 16 6 strsub src 22 4) 0 nil mac 0 1;
		nil
	)
	else if op==2 then
		let larpreq->l in
		(
			set larpreq=filterarpip larpreq src;
			checkarp l src
		);;

fun subnet_ ip i=
	if i<0 then 1
	else if ((strget ip i)^(strget netip i))&(strget netmask i) then 0
	else subnet_ ip i-1;;

fun subnet ip=
	Secho "test subnet "; IPecho ip 0 1;
	Iecholn subnet_ ip 3;;


fun arpreq ip cb=
	let IPecho (if subnet ip then ip else netgateway) 0 1 -> ip in
	let listswitchstr larp ip -> mac in
	if mac!=nil then call cb [mac]
	else
	(
		sendarp ip;
		set larpreq=[ip time cb]::larpreq;	// ### attention à la taille de la liste
		0
	);;

fun filterarp l dt =
	if l!=nil then let hd l->[ip t _] in if (time-t)>dt then filterarp tl l dt
	else
	(
		sendarp ip;
		(hd l)::filterarp tl l dt
	);;

fun arptime =
	set larpreq=filterarp larpreq 10;;

fun resetarp=
	set larp=nil;
	set larpreq=nil;
	0;;

// ------------- ARP fin


// ------------- UDP debut
fun mkudp ipsrc ipdst portsrc portdst content=
	let strcatlist
	"\$aa\$aa\$03\$00\$00\$00\$08\$00\$45\$00\$00\$00\$00\$00\$00\$00\100\17\0\0"::
	ipsrc::
	ipdst::
	"\0\0\0\0\0\0\0\0"::
	content::
	nil -> udp in
	(
		strputword udp 8+2 28+strlen content;
		strputword udp 8+20 portsrc;
		strputword udp 8+22 portdst;
		strputword udp 8+24 8+strlen content;
		strputchk udp 8+10 netChk udp 8 20 0;
		strputchk udp 8+26 netChk udp 8+20 (8+strlen content) netChk udp 8+24 2 netChk "\0\17" 0 nil netChk udp 8+12 8 0;
		udp
	);;

fun udpSend2 mac udp=
	Secho ">u";
//	dump udp;
	netSend udp 0 nil (MACecho mac 0 1) 0 1;;

fun udpsend local localp dst dstp content mac=
	let mkudp local dst localp dstp content -> udp in
	if mac!=nil then udpSend2 mac udp
	else let dst -> ip in	//	ajouter le test de passerelle
	arpreq ip fixarg2 #udpSend2 udp;;

var ludp;;

fun remudp l port=
	if l!=nil then let hd l ->[p _] in if p==port then remudp tl l port else (hd l)::remudp tl l port;;

fun regudp port cb=
	set ludp=[port cb]::remudp ludp port;;

fun unregudp port=
	set ludp=remudp ludp port;;

fun resetudp= set ludp=nil;;

fun cbnetudp src mac=
	Secho "<u";
	let Iecholn strgetword src 8+20+2 -> locp in
	let listswitch ludp locp -> cb in
	call cb [strsub src 8+20+8 nil mac strsub src 20 4];;


// -------------- UDP fin
// ------------- TCP debut
var TFIN=0x01;;
var TSYN=0x02;;
var TRST=0x04;;
var TPUSH=0x08;;
var TACK=0x10;;
var TURGE=0x20;;

var STOFF=-1;;
var STSYN=0;;
var STEST=1;;
var STLISTEN=2;;
var STFIN=3;;

var CLIENT_SEQ_START="\0\0\1\0";;
var CLIENT_SEQ_NULL="\0\0\0\0";;

var TCPWRITE=0;;
var TCPREAD=1;;
var TCPCLOSE=-1;;
var TCPSTART=2;;

var TCPMAX=1024;;

type Tcp=[stateT locT dstT locpT dstpT seqT ackT cbT macT lastsentT retryT locksendT enableT];;

fun mktcp_ ipsrc ipdst portsrc portdst seq ack flag content=
	let strcatlist
	"\$aa\$aa\$03\$00\$00\$00\$08\$00\$45\$00\$00\$00\$00\$00\$00\$00\100\6\0\0"::
	ipsrc::
	ipdst::
	"\0\0\0\0"::
	seq::
	ack::
	"\0\0\$ff\$ff\0\0\0\0"::
	if flag&TSYN then "\2\4\5\$b4"::content::nil	// 5.b4 final : taille MSS
	else content::nil
	-> tcp in
	let strlen tcp ->len in
	(
		strputword tcp 8+2 len-8;
		strputword tcp 8+20 portsrc;
		strputword tcp 8+22 portdst;

		strset tcp 8+32 4*if flag&TSYN then 24 else 20;
		strset tcp 8+33 flag;

		strputchk tcp 8+10 netChk tcp 8 20 0;

		let strnew 2 -> s in
		(
			strputword s 0 len-28;
			strputchk tcp 8+36
			 netChk tcp 8+20 (len-28) netChk s 0 2 netChk "\0\6" 0 nil netChk tcp 8+12 8 0
		);
		tcp
	);;

fun mktcp t flag content=
//	Secholn "mktcp "; Secho "seq "; SEQecho t.seqT 0 1; Secho "ack "; SEQecho t.ackT 0 1;
	mktcp_ t.locT t.dstT t.locpT t.dstpT t.seqT t.ackT flag content;;

fun resendtcp t=
	netSend t.lastsentT 0 nil (MACecho t.macT 0 1) 0 1;
	0;;

fun headerlen src=((strget src 8+32)>>4)<<2;;

fun datalength src=(strgetword src 10)-20-headerlen src;;

fun sendtcp t trame=
//	Secholn "tcpSend"; dump trame;
	netSend trame 0 nil (/*MACecho*/ t.macT /*0 1*/) 0 1;
	let strget trame 8+33 -> flag in
	set t.seqT=netSeqAdd t.seqT (datalength trame)+(if flag&(TSYN|TFIN) then 1 else 0);
	0;;

fun sendtcpforretry t trame=
	set t.lastsentT=trame;
	set t.retryT=nil;
	sendtcp t trame;;


fun tcpSend2 mac tcp trame=
	set tcp.macT=mac;
	sendtcpforretry/*sendtcp*/ tcp trame;;

// List of all current tcp requests
var ltcp;;


fun remtcp t=set t.stateT=STOFF; set ltcp=remfromlist ltcp t;;

var counttcp;;

fun opentcp local localp dst dstp cb=
	let if localp==nil then 1024+set counttcp=((if counttcp==nil then time_ms else counttcp)+1)&16383 else localp -> localp in
	let [stateT:STSYN locT:local dstT:dst locpT:localp dstpT:dstp seqT:CLIENT_SEQ_START ackT:CLIENT_SEQ_NULL cbT:cb enableT:1] -> tcp in
	let mktcp tcp TSYN nil -> trame in
	let dst -> ip in	//	ajouter le test de passerelle
	(
		set ltcp=tcp::ltcp;
		arpreq ip fixarg2 fixarg3 #tcpSend2 trame tcp;
		tcp
	);;

fun listentcp localp cb=
	let [stateT:STLISTEN locpT:localp cbT:cb enableT:1] -> tcp in
	(
		set ltcp=tcp::ltcp
	);;

fun findtcp l localp dstp src=
	if l!=nil then let hd l-> t in
	if t.locpT==localp && t.dstpT==dstp && (!vstrcmp src 8+16 t.locT 0 4)&& (!vstrcmp src 8+12 t.dstT 0 4)
	then t
	else if t.stateT==STLISTEN && t.locpT==localp then t
	else findtcp tl l localp dstp src;;

fun sendclose t=
	Secholn "## sendclose";
	sendtcp t mktcp t TFIN+TACK nil;
	set t.stateT=STFIN;
	0;;

fun cbnettcp src mac=
	Secho "t";
	let /*Iecholn*/ strgetword src 8+20+2 -> locp in
	let /*Iecholn*/ strgetword src 8+20+0 -> dstp in
	let findtcp ltcp locp dstp src -> t in
	if t!=nil && t.enableT then let t.stateT -> st in
		let /*Iecholn*/ strget src 8+33 -> flag in
		let /*SEQecho*/ (strsub src 8+24 4) /*0 1*/-> rseq in
		let /*SEQecho*/ (strsub src 8+28 4) /*0 1*/-> rack in
		if st==STSYN then
		(
			Secholn "stsyn";
			if (flag==TSYN+TACK) && !vstrcmp (SEQecho(t.seqT)0 1) 0 rack 0 4 then
			(
				set t.ackT=SEQecho (netSeqAdd rseq 1) 0 1;
				sendtcp t mktcp t TACK nil;
				set t.stateT=STEST;
				set t.lastsentT=nil;
//				Secholn "call TCPWRITE";
				call t.cbT [t TCPWRITE nil]
			)
			else
			(
//				Secholn "TSRT+TACK";
				sendtcp t mktcp t TRST+TACK nil;
				remtcp t;
				nil
			)
		)
		else if st==STEST then
			if !vstrcmp t.ackT 0 rseq 0 4 then
			let strgetword src 10 -> iplen in
			let ((strget src 8+32)>>4)<<2 -> tcplen in
			let datalength src -> datalen in
			(
				if datalen then
				(
	//				dump src;
	//				Iecholn iplen;
	//				Iecholn tcplen;
//					Secho "update ackT : add ";
					set t.ackT=netSeqAdd t.ackT datalen
				);
				if flag&TFIN then
				(
					set t.ackT=netSeqAdd t.ackT 1;
					nil
				)
				else if !vstrcmp t.seqT 0 rack 0 4 then
				(
//					Secholn "acquittement de l'envoi";
					set t.lastsentT=nil;	// acquittement de l'envoi
					if t.locksendT==1 then
					(
						set t.locksendT=0;
						call t.cbT [t TCPWRITE nil]
					)
					else if t.locksendT==2 then
					(
						sendclose t;
						nil
					)
				)
				else (Secholn "##bad ack"; SEQecho t.seqT 0 1;SEQecho rack 0 1; nil);
				if datalen then
					let 8+20+headerlen src -> start in
					let strsub src start datalen -> data in
					call t.cbT [t TCPREAD data];
				if datalen || flag&TFIN then sendtcp t mktcp t TACK nil;
				if flag&TFIN then
				(
					sendtcp t mktcp t TFIN+TACK nil;
					remtcp t;
					call t.cbT [t TCPCLOSE nil]
				)
			)
			else (/*SEQecho(t.ackT)0 1; SEQecho rseq 0 1;*/Secho "##bs/";sendtcp t mktcp t TACK nil; nil)
		else if st==STFIN then
			(
				Secholn "STFIN";
				set t.ackT=SEQecho (netSeqAdd rseq 1) 0 1;
				sendtcp t mktcp t TACK nil;
				remtcp t;
				nil
			)
		else if st==STLISTEN then
			if flag&TSYN then
			(
				let [stateT:STEST locT:(strsub src 8+16 4) dstT:(strsub src 8+12 4) locpT:locp dstpT:dstp
				seqT:CLIENT_SEQ_START ackT:(netSeqAdd rseq 1) cbT:t.cbT macT:mac  enableT:1] -> tcp in
				(
					set ltcp=tcp::ltcp;
					sendtcpforretry tcp mktcp tcp TACK+TSYN nil;
					call tcp.cbT [tcp TCPSTART nil]
				)
			)
	;;


fun writetcp t msg i=
	if t.stateT!=STEST then nil
	else if t.lastsentT!=nil then
	(
//		Secholn "locksend";
		set t.locksendT=1;
		i
	)
	else let strsub msg i TCPMAX -> content in
	let mktcp t TACK content -> trame in
	(
		sendtcpforretry t trame;
		let i+strlen content -> ni in
		(
			if ni!=strlen msg then set t.locksendT=1;
			ni
		)
	);;


fun closetcp t=
	if t.stateT!=STEST then 0
	else if t.lastsentT!=nil then
	(
		set t.locksendT=2;
		0
	)
	else sendclose t;
	0;;

fun tcpcb t cb= set t.cbT=cb;;

fun enabletcp t v= set t.enableT=v;;
fun enabledtcpP t= t.enableT;;

fun tcptime =
	for l=ltcp;l!=nil;tl l do let hd l-> t in
	if t.lastsentT!=nil then
	(
		if t.retryT!=nil then
		(
			set t.retryT=1+t.retryT;
			if t.retryT>10 then
			(
				remtcp t;
				call t.cbT [t TCPCLOSE nil];
				nil
			)
			else resendtcp t
		)
		else set t.retryT=0
	);
	0;;

fun resettcp=
	set ltcp=nil;
	0;;

// -------------- TDP fin

// --------------- DHCP debut

var DHCP_DISCOVER=1;;
var DHCP_OFFER=2;;
var DHCP_REQUEST=3;;
var DHCP_DECLINE=4;;
var DHCP_ACK=5;;

fun mkdhcp op netip hostip newip =
	let 236+16+14->n in
	let strnew n -> b in
	(
		for i=0;i<n do strset b  i 0;
		strcpy b 0 "\1\1\6" 0 3;
		strcpy b 12 netip 0 4;
		strcpy b 12+16 mymac 0 6;
		strcpy b 236 "\99\130\83\99\53\1" 0 6;
		strset b 236+6 op;
		strcpy b 236+7 "\61\7\1" 0 3;
		strcpy b 236+10 mymac 0 6;
		strcpy b 236+16 "\12\7Pabcdef\55\3\1\3\6" 0 14;
		if op==DHCP_REQUEST then strcatlist b::"\54\4"::hostip::"\50\4"::newip::"\255"::nil
		else strcat b "\255"
	);;

fun mkdhcpans op tid newip dmac=
	let 236+7->n in
	let strnew n -> b in
	(
		for i=0;i<n do strset b  i 0;
		strcpy b 0 "\2\1\6" 0 3;
		strcpy b 4 tid 0 4;
		strcpy b 16 newip 0 4;
		strcpy b 12+16 dmac 0 6;
		strcpy b 236 "\99\130\83\99\53\1" 0 6;
		strset b 236+6 op;
		strcatlist b::"\54\4"::newip::"\51\4\0\1\$51\$80\1\4"::netmask::"\3\4"::netip::"\6\4"::netip::"\15\4home\255"::nil
	);;

fun extractdhcp src i type lease submask dns gateway mac=
	if i<strlen src then
	let strget src i -> c in
	if c==255 then [type lease submask dns gateway mac]
	else let strget src i+1 -> len in
	let i+2->i in
	if c==53 then extractdhcp src i+len (strget src i) lease submask dns gateway mac
	else if c==51 then extractdhcp src i+len type (strgetword src i) submask dns gateway mac
	else if c==1 then extractdhcp src i+len type lease (strsub src i 4) dns gateway mac
	else if c==6 then extractdhcp src i+len type lease submask (strsub src i 4) gateway mac
	else if c==3 then extractdhcp src i+len type lease submask dns (strsub src i 4) mac
	else if c==61 then extractdhcp src i+len type lease submask dns gateway (strsub src i+1 6)
	else extractdhcp src i+len type lease submask dns gateway mac;;

fun mkdhcpip mac=
	let strnew 4 -> s in
	(
		strcpy s 0 netip 0 4;
		strset s 3 ((strget mac 5)&0x7f)+100;
		s
	);;

fun cbnetdhcp src macfrom hostip=
	Secholn "<dhcp"; MACecho macfrom 0 1;
	let strget src 0 -> x in
	let MACecho (strsub src 28 6)0 1 -> mac in
	if x==2 && !strcmp mac mymac then
	(
		let IPecho (strsub src 16 4) 0 1-> newip in
		let extractdhcp src 240 0 nil nil nil nil nil->[type lease submask dns gateway _] in
		if type==DHCP_OFFER then
		(
			Secholn ">>>>>>>>>>>>>>>OFFER";
			udpsend netip 68 ipbroadcast 67 (mkdhcp DHCP_REQUEST netip hostip newip) macbroadcast;
			nil
		)
		else if type==DHCP_ACK then
		(
			Secholn ">>>>>>>>>>>>>>>ACK";
			Secho "server    ";IPecho hostip 0 1;
			Secho "ip        ";IPecho set netip=newip 0 1;
			Secho "type      ";Iecholn type;
			Secho "leasetime ";Iecholn lease;
			Secho "submask   ";IPecho set netmask=submask 0 1;
			Secho "dns       ";IPecho set netdns=dns 0 1;
			Secho "gateway   ";IPecho set netgateway=gateway 0 1;
			nil
		)
	);;

fun cbnetdhcp67 src macfrom hostip=
	Secholn "<dhcp"; MACecho macfrom 0 1;
	let strget src 0 -> x in
	let MACecho (strsub src 28 6)0 1 -> mac in
	if x==1 /*&& !strcmp mac mymac*/ then
	(
		let extractdhcp src 240 0 nil nil nil nil nil ->[type _ _ _ _ dmac] in
		let strsub src 4 4 -> tid in
		let mkdhcpip macfrom -> newip in
		if type==DHCP_DISCOVER then
		(
			Secholn ">>>>>>>>>>>>>>>DISCOVER";
//			dump src;
			udpsend netip 67 ipbroadcast 68 (mkdhcpans DHCP_OFFER tid newip dmac) macbroadcast;
			nil
		)
		else if type==DHCP_REQUEST then
		(
			Secholn ">>>>>>>>>>>>>>>REQUEST";
//			dump src;
			udpsend netip 67 ipbroadcast 68 (mkdhcpans DHCP_ACK tid newip dmac) macbroadcast;
			nil
		)

	);;

fun startdhcp=
	udpsend netip 68 ipbroadcast 67 (mkdhcp DHCP_DISCOVER "\0\0\0\0" nil nil) macbroadcast;
	regudp 68 #cbnetdhcp;
	0;;

fun startdhcpserver=
	regudp 67 #cbnetdhcp67;
	0;;

// --------------- DHCP fin


// --------------- net HOOK debut

fun net src mac=
	Secho "n ";//MACecho mac 0 1;
//	dump src;
	let strget src 7 -> p in
	(
		if p==6 then cbnetarp src mac // ARP
		else if p==0 then
			let strget src 17 -> ip in
			if ip==6 then cbnettcp src mac
			else if ip==17 then cbnetudp src mac;
		0
	);
	buttoncheckevent;
	0;;

fun netstart=
	netCb #net;
	resetarp;
	resettcp;
	resetudp;
	0;;

fun nettime=
	arptime;
	tcptime;
	0;;

// --------------- net HOOK fin

}
else
{

// --------------- TCP/UDP EMULATION debut

var TCPWRITE=0;;
var TCPREAD=1;;
var TCPCLOSE=-1;;
var TCPSTART=2;;

fun udpsend local localp dst dstp content mac=
	udpSend localp dst dstp content 0 nil;;

// ---- WE ARE IN TCP/UDP EMULATION !!

var ludp;;

fun regudp port cb=
	set ludp=[udpStart port cb]::ludp;;

fun resetudp=set ludp=nil;;

fun netudp t src ip=
	let listswitch ludp t -> cb in
	call cb [src nil ip];;

// ---- WE ARE IN TCP/UDP EMULATION !!

var ltcp;;

fun writetcp t msg i=
	tcpSend t msg i nil;;

fun remtcp l t= if l!=nil then let hd l->[tt _] in if t==tt then tl l
	else (hd l)::remtcp tl l t;;

fun updatetcp l t cb= if l!=nil then let hd l->[tt _] in if t==tt then [t cb]::tl l
	else (hd l)::updatetcp tl l t cb;;

// ---- WE ARE IN TCP/UDP EMULATION !!

fun closetcp t=
	set ltcp=remtcp ltcp t;
	tcpClose t;;

fun tcpcb t cb=
	set ltcp=updatetcp ltcp t cb;
	cb;;

fun listentcp port cb=
	set ltcp=[tcpListen port cb]::ltcp;;

// ---- WE ARE IN TCP/UDP EMULATION !!

fun opentcp local localp dst dstp cb=
//	Secholn "opentcp";IPecho dst 0 0; Secho ":"; Iecholn dstp;

	let tcpOpen dst dstp -> t in
	if t!=nil then
	(
		set ltcp=[t cb]::ltcp;
		t
	);;

fun enabletcp t v=
	tcpEnable t v;;
fun enabledtcpP t= 1;; // ?? [as nov07 : I dont know how to emulate this. What is this TCP emulatino mode ?]

// ---- WE ARE IN TCP/UDP EMULATION !!

fun nettcp t val msg=
	if val==TCPSTART then
		let listswitch ltcp atoi msg -> cb in
		(
			if cb==nil then Secholn "callback is nil"
			else Secholn "callback is not nil";
			set ltcp=[t cb]::ltcp;
			call cb [t val msg]
		)
	else let listswitch ltcp t -> cb in
		call cb [t val msg];;

// ---- WE ARE IN TCP/UDP EMULATION !!

fun startdhcp=0;;
fun startdhcpserver=0;;

fun nettime=0;;

fun netstart=
	tcpCb #nettcp;
	udpCb #netudp;
	set ltcp=nil;
	set ludp=nil;
//	set wifi=stationW;
	set netdns=confGetNetdns;
	set netdns="\192\168\1\1";
//	set netdns="\10\0\1\1";
	set netip="\127\0\0\1";
	0;;
// --------------- TCP/UDP EMULATION fin
}

// --------------- DNS debut
fun parsequ s i= let strfind s i "\0" 0 nil -> j in	j+5;;

fun parsequs s i n=	if n<=0 then i else parsequs s parsequ s i n-1;;

fun skipname s i=
	let strgetword s i -> x in
	if (x&0xc000)==0xc000 then i+2
	else (strfind s i "\0" 0 nil)+1;;

fun parseans s i n=
	if n<=0 then nil
	else let skipname s i -> j in
	let strgetword s j -> typ in
	if typ==1 then
		strcatlist (itoa strget s j+10)::"."::(itoa strget s j+11)::"."::
		(itoa strget s j+12)::"."::(itoa strget s j+13)::nil
	else parseans s (j+10+strgetword s j+8) n-1;;

fun parsemsg s=
	let strgetword s 0 -> id in
	let strgetword s 2 -> code in
	let strgetword s 4 -> nbqu in
	let strgetword s 6 -> nbans in
	if nbans==0 then nil
	else let parsequs s 12 nbqu -> i in
	parseans s i nbans;;

fun filterdns src=
	let strfind src 0 "." 0 nil ->i in
	if i!=nil then
		strcat
			strcat ctoa i strsub src 0 i
			filterdns strsub src i+1 nil
	else strcat ctoa strlen src src;;

fun question id dns=
	strcatlist (itobin2 id)::"\$01\$00\$00\$01\$00\$00\$00\$00\$00\$00"::(filterdns dns)::"\$00\$00\$01\$00\$01"::nil;;

var dnsid=0;;

type Dns=[idD domainD reqD timeoutD cbD];;
var ldnsreq;;
var ldns;;

fun dnsreq domain cb=
	set dnsid=if dnsid==nil then time_ms else dnsid+1;
	let listswitchstr ldns domain -> ip in
	if ip!=nil then call cb[ip]
	else let dump question dnsid domain -> tramedns in
	(
		udpsend netip DNSLOCAL netdns 53 tramedns nil;
		set ldnsreq=[idD:dnsid domainD:domain reqD:tramedns timeoutD:time+5 cbD:cb]::ldnsreq;
		nil
	);
	0;;

fun selectbyid d v= d.idD==v;;

fun cbnetdns msg mac ipfrom=
	let strgetword msg 0 -> id in
	let parsemsg msg -> ip in
	let hd select ldnsreq id #selectbyid -> x in
	if x!=nil then
	(
		set ldnsreq=listrem ldnsreq x;
		if ip!=nil then set ldns=[x.domainD ip]::ldns;	// ### attention à la taille de la liste
		call x.cbD [ip]
	);
	0;;

fun filterdnsdead l=if l!=nil then let hd l-> d in if d.timeoutD==nil then filterdnsdead tl l else (hd l)::filterdnsdead tl l;;

fun dnstime=
	for l=ldnsreq;l!=nil;tl l do let hd l-> d in
	if time-d.timeoutD>=0 then
	(
		set d.timeoutD=nil;
		call d.cbD [nil]
	);
	set ldnsreq=filterdnsdead ldnsreq;
	0;;


fun startdnsclient=
	regudp DNSLOCAL #cbnetdns;
	set ldnsreq=nil;
	set ldns=nil;
	0;;

// --------------- DNS fin


//-------------------
var HTTP_NORMAL=0;;
var HTTP_STREAM=1;;
var HTTP_DIRECT=2;;

var HTTP_SOLVE=0;;
var HTTP_REACH=1;;
var HTTP_CONNECTED=2;;

var lasthttpevent;;

// type Httpreq contenant l'état d'une requête
type Httpreq=[cnxH inputH outputH indexH cbH typeH stateH aliveH];;

// callback de lecture sur la socket d'une requête
fun tcpread cnx input httpreq=
	if input==nil ||0==strlen input then	// erreur ou fin
	(	closetcp cnx;	// on ferme la socket
		if httpreq.typeH==HTTP_NORMAL then call httpreq.cbH [httpreq strcatlist rev httpreq.inputH nil]	// on retourne ce qui a été reçu
		else call httpreq.cbH [httpreq nil] // HTTP_STREAM or HTTP_DIRECT
	)
	else
	(
//		dump input;
		set lasthttpevent=time;
		set httpreq.aliveH=time_ms;
		if httpreq.typeH==HTTP_NORMAL then set httpreq.inputH=input::httpreq.inputH	// on bufferise ce qui a été reçu
		else if httpreq.typeH==HTTP_DIRECT then
		(
			call httpreq.cbH [httpreq input];
			nil
		)
		else let strcat hd httpreq.inputH input -> s in
		let strstr s "\13\10\13\10" 0 -> i in
		if i==nil then
		(
			set httpreq.inputH=s::nil
		)
		else
		(
			set httpreq.inputH=nil;
			set httpreq.typeH=HTTP_DIRECT;
			call httpreq.cbH [httpreq strsub s 0 i];
			if i+4<strlen s then call httpreq.cbH [httpreq strsub s i+4 nil];
			nil
		);
		nil
	);;

// callback d'écriture sur la socket d'une requête
fun tcpwrite cnx httpreq=
	set httpreq.stateH=HTTP_CONNECTED;
	set httpreq.aliveH=time_ms;
	if httpreq.outputH!=nil then	// s'il y a des choses à envoyer (notamment la première fois)
	(
		set httpreq.indexH=writetcp cnx httpreq.outputH httpreq.indexH;	// envoyer ce qui peut l'être
		if httpreq.indexH==nil then	// si erreur lors de l'envoi
		(	closetcp cnx;	// on ferme la socket
			call httpreq.cbH [httpreq nil]	)	// on retourne nil
		else if httpreq.indexH>=strlen httpreq.outputH then	// sinon si tout a été envoyé
		(	set httpreq.indexH=nil;	// purger les données d'émission
			set httpreq.outputH=nil;
			nil
		)
	);;

var http_prefurl="http://";;	// en-tête normal (mais ici facultatif) d'une requête http

fun isip s i=
	if i>=strlen s then 1
	else let strget s i -> c in
	if (c<'0' || c>'9')&&c!='.' then 0
	else isip s i+1;;


// découper une url en [host port path].
// host est de la forme ip:port
// path ne commence pas par /
fun cuturl url =
	if !strcmp (strsub url 0 strlen http_prefurl) http_prefurl then cuturl strsub url strlen http_prefurl strlen url
	else let strstr url "/" 0 -> i in
		let if i==nil then url else strsub url 0 i -> addr in
		let strstr addr ":" 0 -> j in
		let if j==nil then [addr 80]
			else [strsub addr 0 j atoi strsub addr j+1 strlen addr] -> [host port] in
		let if i==nil then "/" else strsub url i strlen url -> path in
		[host port path];;

fun tcpevent t val msg sock=
	if val==TCPWRITE then tcpwrite t sock
	else if val==TCPCLOSE then tcpread t nil sock
	else tcpread t msg sock;
	0;;


fun httpsendreq ip x=
	Secho "found ip>>>>>>>>>>>>>>>>>>>>>>>>>"; Secholn ip;
	let x->[port httpreq] in
	if ip==nil then (call httpreq.cbH [httpreq nil]; nil)
	else
	(
		set httpreq.cnxH=opentcp netip nil useparamip ip port fixarg4 #tcpevent httpreq;
		set httpreq.stateH=HTTP_REACH;
		nil
	);
	0;;


//##> création d'une requête http
// paramètres : verb=verbe de la requête url=url de la requête postdata=données supplémentaires (nil si aucune) cb=callback de retour
fun httprequest verb url postdata cb type=
//	Secho "HTTPREQUEST url =";Secholn url;
	let cuturl url ->[host port path] in	// décodage de l'url de la requête
	let if confGetProxy then strcatlist "http://"::host::":"::(itoa port)::path::nil else path -> path in //Icy-MetaData:1\13\n
	let strcatlist verb::" "::path::" HTTP/1.0\13\nUser-Agent: MTL\13\nPragma: no-cache\13\nIcy-MetaData:1\13\nHost: "::host::"\13\n"::
			if postdata==nil then "\13\n"::nil
			else "Content-length: "::(itoa strlen postdata)::"\13\n\13\n"::postdata::nil
		-> request in	// création de la chaîne requête
	let if confGetProxy then webip confGetProxyip else host -> host in
	let if confGetProxy then confGetProxyport else port -> port in
	let [outputH:request indexH:0 cbH:cb typeH:type stateH:HTTP_SOLVE aliveH:time_ms] -> httpreq in	// création de la structure requête
	(
//		Secho "HTTPREQUEST host =";Secholn host;
		if isip host 0 then httpsendreq host [port httpreq]
		else
		(
			dnsreq host fixarg2 #httpsendreq [port httpreq];
			nil
		);
		httpreq	// on retourne la structure requête pour pouvoir éventuellement l'interrompre en cours de route
	);;

//##> interruption d'une requête en cours
fun httpabort httpreq=
	closetcp httpreq.cnxH;;	// on ferme la socket de la requête

fun httpenable httpreq v=
	enabletcp httpreq.cnxH v;;
fun httpenabledP httpreq=
	enabledtcpP httpreq.cnxH;;

fun httpstate httpreq = httpreq.stateH;;

fun httpinactive httpreq = time_ms-httpreq.aliveH;;


var http_sep="\13\n\13\n";;	// séparateur entre l'en-tête et le corps de la réponse à une requête



//##> retourne le header d'une réponse à une requête
fun httpgetheader res =
	let strstr res http_sep 0 -> i in
	if i==nil then res
	else strsub res 0 i+strlen http_sep;;

//##> retourne le contenu d'une réponse à une requête (sans header)
fun httpgetcontent res =
	let strstr res http_sep 0 -> i in
	if i==nil then nil
	else strsub res i+strlen http_sep strlen res;;

//-------------------

ifdef RECLIB {
var lrec;;
var recording=0;;

fun sqrt_ i i0 i1=
	let (i0+i1)>>1 -> m in
	if m==i0 then i0
	else if m*m>i then sqrt_ i i0 m else sqrt_ i m i1;;
fun sqrt i=sqrt_ i 0 256;;

fun cbrec s=
	Iecho strlen s; Secho "!";
	let 255-(Iecholn sqrt recVol s 0) -> vol in
	let 255-((vol*vol)>>8) -> vol in
	let vol<<16 -> vol in
	(
		led 1 vol; led 2 vol; led 3 vol
	);
	set lrec=s::lrec;
	0;;

fun itobin4 i=
	let strnew 4 -> s in
	(
		strset s 0 i;
		strset s 1 i>>8;
		strset s 2 i>>16;
		strset s 3 i>>24;
		s
	);;

fun liststrlen l r=	if l==nil then r else liststrlen tl l r+strlen hd l;;

fun mkriff ldata=
	Secho "mkriff len=";
	let Iecholn liststrlen ldata 0 -> len in
	(strcatlist "RIFF"::(itobin4 len+52)::"WAVEfmt \$14\0\0\0\$11\0\1\0\$40\$1f\0\0\$d7\$0f\0\0\0\1\4\0\2\0\$f9\01"::
	"fact\4\0\0\0"::(itobin4 (len>>8)*505)::"data"::(itobin4 len)::nil)::ldata;;

fun recstart =
	recStop;
	Secholn "record";
	set recording=1;
	set lrec=nil;
	recStart 8000 0 #cbrec;;

fun recstop =
	set recording=0;
	recStop;;

fun recriff =
	let mkriff rev lrec nil -> res in
	(
		set lrec=nil;
		res
	);;
}

ifdef AUDIOLIB {

// wav playback

var WAV_IDLE=0;;
var WAV_RUN=1;;
var WAV_EOF=2;;

var WAV_BUFFER_STARTSIZE=80000;;
var WAV_BUFFER_MAXSIZE=400000;;

var WAV_END_TIMEOUT=500;;
var WAV_NET_TIMEOUT=15000;;

var wav_end_timeout;;

var wav_http_cb=nil;;
var wav_state=0;;
var wav_http;;
var wav_fifo;;
var wav_buffering=0;;
var wav_buffering_since=0;;
var wav_index;;
var wav_lasttime;;
var wav_lastnet;;
var wav_zeros;;
var wav_curplayedbytes=0;;

var lastvol;;
var forcedvol=0;;
fun volfrombutton v=let 255-v -> v in 255-((v*v)>>8);;

fun updatevol=
	let button3 -> v in
	if !forcedvol && v!=lastvol && (!recording) && (lastvol!=255 || v<250) then
	(
		set lastvol=v;
		sndVol volfrombutton v
	);;

fun forcevol v=
	sndVol volfrombutton (button3*v)>>8;
	set forcedvol=1;
	0;;
fun unforcevol=
	set forcedvol=0;
	set lastvol=nil;
	0;;

fun wavgetzeros=
	if wav_zeros==nil then
	(
		set wav_zeros=strnew 2048;
		for i=0;i<2048 do strset wav_zeros i 0
	);
	wav_zeros;;

fun wavstop =
Secholn "###wavstop";
	if wav_state!=WAV_IDLE then
	(
		playStop;
		if wav_http!=nil then httpabort wav_http;
		set wav_http=nil;
		set wav_buffering = 0;
		set wav_state=WAV_IDLE
	);;

fun wavrunning =
	if wav_state==WAV_IDLE then 0
	else if wav_fifo==nil && wav_state==WAV_EOF && (time_ms-wav_lasttime>wav_end_timeout) then
	(
Secholn "###wav detected end";
		wavstop;
		0
	)
	else if wav_lasttime==nil then -1 else 1;;

// The main wav playback callback
// reads from wav_fifo and feeds playFeed
fun _wavplaycb i =
//Secho "p";
	set wav_lasttime=time_ms;
//	Iecho i;Secho ":cbplay\n";
	if wav_fifo==nil then
	(
		// nothing in fifo
		if wav_state==WAV_EOF then playFeed nil nil nil
		else if !wav_buffering then (
			Secho ">>>>buffering";
			set wav_buffering=1;
			set wav_buffering_since = time_ms
		)
	)
	else
	(
		// was buffering ?
		if wav_buffering && (wav_state==WAV_EOF || (slistlen wav_fifo)>=WAV_BUFFER_STARTSIZE) then
		(
			Secholn "<<<<end_buffering";
			set wav_buffering=0
		);
		if !wav_buffering then
		let hd wav_fifo -> sample in
		let strlen sample -> len in
		(
			// push sample data
			// wav_index is the index within the current sample.
			if wav_index<len then (
				// send some bytes to the VM buffer.
				let (playFeed sample /*Iecho*/ wav_index nil) -> pushedbytes in (
					// this is how many bytes we sent.
					set wav_index=wav_index+pushedbytes;
					// compute wav_curplayedbytes
					set wav_curplayedbytes = wav_curplayedbytes + pushedbytes
				)
			);
			if wav_index>=len then
			(
				// we sent the whole first sample.
				// (in fact, wav_index cannot be bigger than len).
				// reset the counter on the sample and transition to the next sample.
				set wav_index=0;
				set wav_fifo=tl wav_fifo;
				// Secho "[b-:" ; Iecho (slistlen wav_fifo); Secho "]";
				if wav_http!=nil then if (slistlen wav_fifo)<WAV_BUFFER_MAXSIZE then if !(httpenabledP wav_http) then
				(
					Secho "##http restart##";
					httpenable wav_http 1
				)
			)
		)
	);
	0;;

fun _wavstartnow =
	set wav_index=0;
	set wav_buffering=1;
	set wav_buffering_since = time_ms;
	set wav_curplayedbytes=0;
	playStart 1024 #_wavplaycb;;

fun wavstartlocalEx l timeout=
	wavstop;
	set wav_end_timeout=timeout;
	set wav_fifo=conc l (wavgetzeros)::nil;
	set wav_state=WAV_EOF;
	set wav_lasttime=time_ms;
	set wav_http=nil;
	_wavstartnow
	;;

fun wavstartlocal l=wavstartlocalEx l WAV_END_TIMEOUT;;

fun _wavcbhttp httpreq req=
	Secho "w";
	set wav_lastnet=time_ms;
	if req==nil then
	(
		Secholn ">>>>>>>>>>>>>>>>>>>>>>>>>>>>><end of file";
		set wav_state=WAV_EOF;
		if wav_fifo!=nil then set wav_fifo=conc wav_fifo (wavgetzeros)::nil;
		if wav_index==nil then
		(
			// had never started wav playback
			// check if something in fifo. If yes, play it, if not stop wav
			set wav_fifo=tl wav_fifo;
			if wav_fifo==nil then wavstop
			else _wavstartnow
		);
		0
	)
	else
	(
//		dump req;
		set wav_fifo=conc wav_fifo req::nil;
		let (slistlen wav_fifo) -> n in
		(
		// Secho "[b+:"; Iecho n ; Secho "]";
		if wav_index==nil && n>WAV_BUFFER_STARTSIZE then
		(
			// had never started wav playback : start it
			set wav_fifo=tl wav_fifo;
			_wavstartnow
		) else if n>WAV_BUFFER_MAXSIZE then (
			Secho "##http wait##";
			httpenable httpreq 0
		);
		nil
		)
	);
	updatevol;
	0;;

fun wavstarthttp url cb=
	wavstop;
	set wav_http_cb = cb;
	set wav_end_timeout=WAV_END_TIMEOUT;
	set wav_fifo=nil;
	set wav_state=WAV_RUN;
	set wav_index=nil;
	set wav_buffering=1;
	set wav_buffering_since = time_ms;
	set wav_lasttime=nil;
	set wav_lastnet=time_ms;
	set wav_http=httprequest "GET" url nil #_wavcbhttp HTTP_STREAM;;

fun wavtime =
	// Check timeout against wav_buffering_since
	if (wav_http!=nil && wav_state==WAV_RUN && wav_buffering && (time_ms - wav_buffering_since > WAV_NET_TIMEOUT)) then (
		Secho "wavhttp timeout";
		wavstop;
		if (wav_http_cb != nil) then call wav_http_cb []
	);
	0;;

}


//-------------------

ifdef EARSLIB {

// ears management
var EARSMODE_RESET=0;;
var EARSMODE_WAIT=1;;
var EARSMODE_WAITANDDETECT=2;;
var EARSMODE_DETECT=3;;

var EARS_HOLES=17;;
var EARS_TIMEOUT=2000;;
var EARS_OFFZERO=2;;

type Ear=[numE dirE targetE targetLoopE posE lvalE ldelayE ltimeE countE brokenE];; // v16 +targetLoopE

var ears;;
var earsmode;;
var earslastmove;;	// somme des deux compteurs
var earslastmovetime;;	// heure du dernier mouvement (=nil=> acquisition en cours)

var earevent;;

fun eargetevent=
	let earevent -> ev in
	(
		set earevent=nil;
		ev
	);;

// v16 +fun earLoop;;
fun earLoopCount v prevLoop=
	if v<0 then earLoopCount v+EARS_HOLES prevLoop-1
	else if v>=EARS_HOLES then earLoopCount v-EARS_HOLES prevLoop+1
	else prevLoop;;

fun earCheck v=
	if v<0 then earCheck v+EARS_HOLES
	else if v>=EARS_HOLES then earCheck v-EARS_HOLES
	else v;;

fun earMotorset e val=
	set e.dirE=val;
	motorset e.numE val;;

fun earReset=
Secholn "earReset";
	set earsmode=EARSMODE_RESET;
	for i=0;i<2 do let ears.i -> e in
	(
		earMotorset e 1;
		set e.brokenE=0;
		set e.targetE=nil;
		set e.targetLoopE=nil; // v16
		set e.lvalE=motorget i;
		set e.ldelayE=nil;
		set e.ltimeE=time_ms
	);;

fun earInit =
	set ears=tabnew nil 2;
	for i=0;i<2 do set ears.i=[numE:i];
	earReset;;


fun earStartDetect=
	setleds 0xff8000;
	set earsmode=EARSMODE_DETECT;
	set earslastmovetime=time_ms;
	set earslastmove=(motorget 0)+(motorget 1);;


fun earDetectRun=
	if earslastmovetime!=nil then
	(
		let (motorget 0)+(motorget 1)->newval in
		if newval!=earslastmove then
		(
			Secho "new val ";Iecholn newval;
			set earslastmove=newval;
			set earslastmovetime=time_ms
		)
		else if time_ms-earslastmovetime>EARS_TIMEOUT then
		(
			set earslastmovetime=nil;
			for i=0;i<2 do let ears.i -> e in
			if e.brokenE!=1 then
			(
				set e.lvalE=motorget i;
				set e.ldelayE=0;
				set e.ltimeE=time_ms;
				earMotorset e 1;
				set e.countE=e.lvalE+EARS_HOLES
			)
		)
	)
	else
	(
		for i=0;i<2 do let ears.i -> e in
			if e.brokenE!=1 then
			if e.dirE then
			let motorget i -> v in
			if v!=e.lvalE then
				let time_ms -> t in
				let t-e.ltimeE -> d in
				(
					if d>e.ldelayE then
					(
						set e.posE=earCheck e.countE-e.lvalE-EARS_OFFZERO-1;
						set e.ldelayE=d
					);
					set e.ltimeE=t;
					set e.lvalE=v;
					if v-e.countE>=0 then earMotorset e 0
				);
		if (ears.(0).dirE)==0 && (ears.(1).dirE)==0 then
		(
			set earevent=0x8000+(ears.(0).posE<<8)+(ears.(1).posE);
			Secho "Acquisition : "; Iecho ears.(0).posE; Secho ", ";Iecholn ears.(1).posE;
			set earsmode=EARSMODE_WAITANDDETECT
		)
	);;

fun earResetRun=
	for i=0;i<2 do let ears.i -> e in
	if e.dirE then
	(
		let motorget i -> v in
		if v==e.lvalE then
		(
			let time_ms -> t in
			let t-e.ltimeE -> d in
			if d>5000 then
			(
				Secholn "broken :"; Iecholn i;
				set e.brokenE=1;
				set e.posE=0;
				set e.lvalE=v;
				set e.targetE=0;
				set e.targetLoopE=0; // v16
				set e.ldelayE=0;
				earMotorset e 0
			)
		)
		else
		if e.targetE!=nil then
		(
			set e.posE=earCheck e.posE+v-e.lvalE;
			set e.lvalE=v;
			if e.posE==e.targetE then
				if e.targetLoopE == 0 then
					earMotorset e 0
				else if e.dirE>0 then set e.targetLoopE = e.targetLoopE-1
				else set e.targetLoopE = e.targetLoopE+1
		)
		else
		let time_ms -> t in
		let t-e.ltimeE -> d in
		(
			if (d<10000) && (d>600) && (nil!=e.ldelayE) then
			(
	//			Secho "gowait "; Iecholn d; Iecholn ldelay;
				set e.posE=earCheck -EARS_OFFZERO;
				set e.targetE=0;
				set e.targetLoopE=0 //v16
			)
			else
			(
	//			Secho "position "; Iecho e.numE; Secho " : "; Iecho v; Secho " during "; Iecholn d;
				set e.ltimeE=t
			);
			set e.lvalE=v;
			set e.ldelayE=d
		)
	);
	if (ears.(0).dirE)==0 && (ears.(1).dirE)==0 then
	(
		set earsmode=EARSMODE_WAIT
	);;

fun earWaitRun=
	for i=0;i<2 do let ears.i -> e in
	if e.brokenE!=1 then
	(
		let motorget i -> v in
		if v!=e.lvalE then
		let v-e.lvalE-> dv in
		if e.dirE then
		(
			// Oreille en train de tourner
			set e.lvalE=v;
			set e.posE=earCheck e.posE+ if e.dirE>0 then dv else -dv;
			if e.posE==e.targetE then
			(
//					Secho "stop "; Iecholn e.numE;
				if e.targetLoopE == 0 then //v16
				earMotorset e 0
				else if e.dirE>0 then set e.targetLoopE = e.targetLoopE-1 //v16
				else set e.targetLoopE = e.targetLoopE+1 // v16
			)
		)
		else if dv>2 then
		(
			// Pas de mvt autonome.
			// Veut dire qu'une oreille a ?t? tourn?e par l'utilisateur :
			// si interactif : le noter
			// sinon passer en mode detect
			set e.lvalE=v;
			if gInteractiveApp != nil then
				(interactiveNoteEarTouched i v dv)
			else if earsmode==EARSMODE_WAITANDDETECT then
				earStartDetect
		)
	);;

// boucle pour faire tourner les oreilles vers leur targetobjectif
fun earRun=
	if earsmode==EARSMODE_RESET then earResetRun
	else if earsmode==EARSMODE_DETECT then earDetectRun
	else earWaitRun;
	0;;

fun earReady= earsmode!=EARSMODE_RESET;;
fun earDetecting= earsmode==EARSMODE_DETECT;;
fun earComplete = earReady && (!ears.(0).dirE) && (!ears.(1).dirE);;

fun earDetect=
	if earsmode== EARSMODE_WAIT then set earsmode=EARSMODE_WAITANDDETECT;;

fun earUndetect=
	if earsmode== EARSMODE_WAITANDDETECT then set earsmode=EARSMODE_WAIT;;

fun earStop=
	Secholn "earStop";
	if earsmode!=EARSMODE_RESET then for i=0;i<2 do earMotorset ears.i 0;
	0;;

fun earTarget i= ears.(i).targetE + ears.(i).targetLoopE*EARS_HOLES;; // v16

// oreille i doit aller  position p dans direction d
// i==0 : droite, i==1 : gauche
// p = int quelconque, mme > 17
// d==0 : vers l'avant, d!=0 : vers l'arrire
fun earGo i p d=
	if earsmode==EARSMODE_WAIT ||earsmode==EARSMODE_WAITANDDETECT then
	let ears.i->e in
	let (if d then -1 else 1) -> dir in // v16
	if e.brokenE==1 then
	(
		Secho "earGo ";Iecho i; Secholn " broken !";
		nil
	)
	else
	if p!=earTarget i then //v16 add start
	(
		Secho "earGo ";Iecho i; Secho " to ";Iecho p;Secho " dir ";Iecholn d;
		set e.targetE=earCheck p;
		set e.targetLoopE=earLoopCount p 0;
		Secho "targetE=";Iecho e.targetE; Secho " targetLoopE="; Iecholn e.targetLoopE;
		if e.posE==e.targetE then
			if e.targetLoopE==0 then
			earMotorset e 0 // on est arrivés
			else
			(
				if dir>0 then set e.targetLoopE = e.targetLoopE - 1
				else set e.targetLoopE = e.targetLoopE + 1;
				earMotorset e dir
			)
		else (
		if e.targetLoopE<0 then set e.targetLoopE=e.targetLoopE+1; // sinon fait un tour de trop
		earMotorset e dir //v16 add end
		)

	);
	0;;

}

//-------------------
ifdef INFOLIB {

// gestion des services
// v21 : chang? la gestion du tempo : maintenant gestion bas?e sur le temps r?el (bug 195)
// v21 : chang? animation orage (bug 202)
// v21 : chang? couleur de palette de traffic (de 9  1) (bug 197)

// infodata : les definitions des animations visuelles des services (meteo, traffic, etc..)
// Liste de tuples. Un tuple = [<type de service> <animations>]
// animations = tableau de N animations, une par valeur du service. Animation = tuple = [tempo <couleurs>]
// couleurs = X fois 3 couleurs pour les 3 leds du ventre (led 1, 2, 3)
// couleur = index dans le tableau 'infoPalette'
// tempo = 0.5*log2 du nombre d'it?rations  durer sur la couleur courante (ex : tempo = 3, dur?e = 16 it?rations)
var infodata;;

// infosrc : les services courants affich?s par ce lapin (envoy? par le serveur et mis  jour par le fonction 'infoUpdate')
// Un tableau de 32 valeurs.
// Les 16 premires entr?es sont pour les services courants. 2 valeurs par service donc 8 services max.
// 2 valeurs par service : la premire valeur vaut 1+infoType (ex : 1 pour meteo), la deuxime vaut infoVal, la valeur du service (ex : 0 pour soleil)
// Les valeurs suivantes semblent utilis?es par le serveur pour divers usages:
// Il semble que le serveur stocke des choses dans les cases 18 et 19 de infosrc (messages en attente par exemple)
var infosrc;;

fun infoInit=
	set infosrc=tabnew 0 32;

	set infodata=
[0 // meteo
{
	[25 {3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0}] // soleil
	[125 {0 3 0 4 0 4}] // nuages
	[25 {4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0}] // brouillard
	[20 {0 0 0 0 4 0 4 0 4 0 0 0 0 0 4 4 0 0 0 0 0 0 4 0 0 0 4}] // pluie
	[40 {4 0 0 0 0 0 0 0 4 0 0 0 0 4 0 0 0 0 0 0 4 0 0 0 0 4 0 0 0 0 4 0 0 0 0 0}] // neige
	[25 {0 4 3 0 0 0 0 0 0 0 0 0 0 0 0 4 3 0 0 4 3 0 0 0 0 0 0 0 3 4 3 4 0}] // orage
}
]::
[1 // bourse
{
	[7 {0 0 11 0 11 0 11 0 0 0 0 0 0 0 0 0 0 0}]
	[14 {0 0 11 0 11 0 11 0 0 0 0 0}]
	[28 {0 0 11 0 11 0 11 0 0 0 0 0}]
	[28 {0 11 0 0 0 0}]
	[28 {11 0 0 0 11 0 0 0 11 0 0 0}]
	[14 {11 0 0 0 11 0 0 0 11 0 0 0}]
	[7 {11 0 0 0 11 0 0 0 11 0 0 0 0 0 0 0 0 0}]
}
]::
[2 // traffic
{
	[100 {1 0 1 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0}]
	[100 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[50 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[25 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[12 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[8 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
	[4 {0 1 0 1 0 1 0 1 0 1 0 1 0 0 0 0 0 0}]
}
]::
[5 // mails
{
	[70 {5 0 0 0 5 0 0 0 5 0 5 0}]
	[56 {0 5 0 0 0 0}]
	[56 {5 0 5 0 0 0}]
	[56 {5 5 5 0 0 0}]
}
]::
[6 // pollution
{
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[42 {6 6 6 6 6 6 6 6 6 0 0 0}]
	[14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
	[14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
	[14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
	[14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
	[14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
	[14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
}
]::
nil;;

// v21 : chang? couleur jaune clair (11) de 0xffff80  0xffcc00 (bug 197)
var infoPalette={
//  noir     rouge    vert     jaune    bleu     violet   cyan     blanc
	0x000000 0xff0000 0x00ff00 0xffff00 0x0000ff 0xff00ff 0x00ffff 0xffffff
//  gris     rose     G clair  J clair  B clair  V clair  C clair  orange
	0x808080 0xff8080 0x80ff80 0xffcc00 0x8080ff 0xff80ff 0x80ffff 0xff8000
};;


// heure de d?marrage du service courant
var infoStartTime;;
// index du service courant (dans infosrc)
var infoIndex=0;;
// type du service courant
var infoType;;
// valeur du service courant
var infoVal;;
// index de la couleur dans le tableau des couleurs de l'animation courante
var infoAnimColori;;
// Date de d?marrage de la couleur..
var infoAnimColorStart;;
// dur?e de la couleur...
var infoAnimColorDur;;

// dur?e d'affichage d'un service, en secondes
// v21 : pass?  15s
var INFO_TIMEOUT=15;;

fun infoAnimationsOf typ=listswitch infodata typ;;

// retourne le prochain index utile (infoType non nul)
fun infoNextIndex i=
	let i+2-> i in
	if i>=16 then 0 else if infosrc.i then i else infoNextIndex i;;

// le service suivant
fun infoNext=
	set infoIndex=infoNextIndex infoIndex;
	set infoType=(infosrc.(infoIndex))-1;
	set infoVal=infosrc.(infoIndex+1);
	set infoStartTime=time;
	set infoAnimColori=0;
	set infoAnimColorStart=time_ms;
	let infoAnimationsOf infoType -> anims in
	if anims==nil then set infoStartTime=nil
	else let anims.infoVal ->[dur _] in set infoAnimColorDur= dur*10;
	0;;

fun dumpinfosrc=
	for i=0;i<16 do (Iecho infosrc.i;Secho " : ");
	Secholn ""
	;;

fun infoRun=
	if (gInteractiveApp == nil) then // no info while in interactive mode
	if !earDetecting then
	(
		// passage au service suivant ?
		set infoType=(infosrc.(infoIndex))-1;
		if infoStartTime==nil || (time-infoStartTime>INFO_TIMEOUT) || infoType<0 then infoNext;

		// Allumage de la tte en violet si message(s) en attente (cases 18 et 19 de infosrc)
		let infosrc.(16+2) -> msg1 in
		let infosrc.(16+3) -> msg2 in
		let (time_ms>>8)&7 -> t in
			led 0 if (t==1 && msg1) || (t==3 && msg1 && msg2) then 0xff00ff else 0;

		// couleurs des 3 leds du ventre (service courant/animation courante/couleur courante)
		set infoType=(infosrc.(infoIndex))-1;
		set infoVal=infosrc.(infoIndex+1);
		let infoAnimationsOf infoType -> anims in
		let anims.infoVal ->[dur anime] in
		if anime!=nil then
		(
			led 1 infoPalette.(anime.infoAnimColori);
			led 2 infoPalette.(anime.(1+infoAnimColori));
			led 3 infoPalette.(anime.(2+infoAnimColori));
			if (time_ms-infoAnimColorStart >= infoAnimColorDur) then
			(
				// next colors
				set infoAnimColori=infoAnimColori+3;
				set infoAnimColorStart=time_ms;
				set infoAnimColorDur= dur*10;
				if infoAnimColori>=tablen anime then set infoAnimColori=0
			)
		)
		else
		(
			led 3 0; led 2 0; led 1 0
		)
	);;

// fonction de mise  jour de infosrc (appel? par la boucle de r?ception des messages du serveur '_pingcbhttp')
fun infoUpdate data=
	let strlen data -> len in
	for i=0;i<len do set infosrc.i=strget data i;
	0;;

fun infoGet_ i typ=
	if i>=tablen infosrc then 0
	else if typ==infosrc.i then infosrc.(i+1)
	else infoGet_ i+1 typ;;

// Retourne la valeur du type de service donn?.
// Attention : gestion sp?ciale du type taichi (TYPE_taichi). Il semble que le serveur permette au lapin de faire du taichi en donnant
// une valeur non nulle au service TYPE_taichi (14).
// En fait, cette fonction est utilis?e uniquement pour le taichi...
fun infoGet typ=infoGet_ 0 typ;;

}

//-------------------



fun setleds col= for i=0;i<5 do led i col;;


var RT2501_S_BROKEN=0;;
var RT2501_S_IDLE=1;;
var RT2501_S_SCAN=2;;
var RT2501_S_CONNECTING=3;;
var RT2501_S_CONNECTED=4;;
var RT2501_S_MASTER=5;;

var IEEE80211_M_MANAGED=0;;
var IEEE80211_M_MASTER=1;;

var wifitry;;



fun _scanserialize l=
	if l!=nil then
	let hd l->[ssid mac bssid rssi channel rateset encryption] in
	ssid::"\0"::mac::bssid::(itoh4 rssi)::(itoh4 channel)::(itoh4 rateset)::(itoh4 encryption)::
	_scanserialize tl l;;

fun scanserialize l=
	(itoh4 listlen l)::_scanserialize l;;


fun ssidlen s i=
	if i>=strlen s then i
	else if !strget s i then i
	else ssidlen s i+1;;

fun scanunserialize s n i0=
	if n>0 then
	let ssidlen s i0 -> j in
	let j+1->i in
	[
		strsub s i0 j-i0
		strsub s i 6
		strsub s i+6 6
		htoi strsub s i+12 8
		htoi strsub s i+20 8
		htoi strsub s i+28 8
		htoi strsub s i+36 8
	]::scanunserialize s n-1 i+44;;


fun envmake =
	strcatlist netip::netmask::netgateway::netdns::scanserialize wifiscans;;

fun envrestore s =
	if s!=nil then
	(
		set netip=strsub s 0 4;
		set netmask=strsub s 4 4;
		set netgateway=strsub s 8 4;
		set netdns=strsub s 12 4;
		let htoi strsub s 16 8 -> nscan in
		set wifiscans=scanunserialize s nscan 24;
		0
	);;

fun scancmpssid a b=
	let a->[sa _ _ _ _ _ _] in
	let b->[sb _ _ _ _ _ _] in
	strcmp sa sb;;


fun wifiInit rescan=
	set wifitry=nil;
	let envget -> env in
	if env==nil then
	(
		setleds 0xff00ff;
		set wifi=initW;
		if rescan then set wifiscans=nil;
		if master then
		(
			set netip=netip_master;
			set netmask=netmask_master;
			set netgateway=netgateway_master;
			0
		)
		else
		(
			if confGetDhcp then	set netip=netip_empty
			else
			(
				set netmask=confGetNetmask;
				set netgateway=confGetNetgateway;
				set netdns=confGetNetdns;
				set netip=confGetNetip
			);
			0
		);
		0
	)
	else
	(
		setleds 0x00ff00;
		set mymac=netMac;
		set wifi=stationW;
		envrestore env;
		envset nil;
		nil
	);
	0;;

var laststate;;

fun wifibyssid x v=let x->[s _ _ _ _ _ _] in (s!=nil)&& !strcmp v s;;


var retrytime;;

fun _wifiwepkey val i len=
	if i<len then
	(htoi strsub val i 2)::_wifiwepkey val i+2 len;;

fun wifiwepkey val=
	let strlen val -> len in
	if len==5 || len==13 then val
	else let strreplace val ":" "" -> val in
	let if len<10 then 0 else if len<26 then 5 else 13 -> len in
	listtostr _wifiwepkey val 0 len<<1;;

fun wificrypttype crypt key=
	if crypt==1 then if 5==strlen key then IEEE80211_CRYPT_WEP64 else IEEE80211_CRYPT_WEP128
	else if crypt==2 then IEEE80211_CRYPT_WPA
	else IEEE80211_CRYPT_NONE;;

fun wifiAuth=
	setleds 0xff8000;
	if wifiscans==nil then 0
	else
		let Iecholn confGetWificrypt -> crypt in
		let confGetWifiauth -> auth in
		let if crypt==1 then wifiwepkey confGetWifikey0
			else if crypt==2 then confGetWifipmk -> key in
		(
			dump key;
			set wifitry=time;
			netAuth hd wifiscans Iecholn auth (Iecholn wificrypttype crypt key) key;	//## ajouter les paramètres de crypto
			1
		);;

fun wifiRun=
	let netState -> state in
	(
		if state!=laststate then (Secho "wifi state=";Iecholn state);
		let match wifi with
		(stationW -> nil)
		|(initW -> if state==RT2501_S_IDLE then
				(
					set mymac=MACecho netMac 0 1;
					setleds 0xff8000;
					if master then
					(
						dumpscan set wifiscans=sort netScan nil #scancmpssid;
						netSetmode IEEE80211_M_MASTER (strcat "Nabaztag" ctoh strget mymac 5) 1;
						Secholn "-------------gomaster";
						gomasterW
					)
					else
					(
						if wifiscans==nil then
						(
							let confGetWifissid -> ssid in
							let if strlen ssid then ssid else nil -> ssid in
							let netScan ssid -> lscan in
							let sort lscan #scancmpssid -> l in
							let if ssid==nil then l else select l ssid #wifibyssid-> l in
							dumpscan set wifiscans=l
						);
						if wifiAuth then
						(
							Secho confGetWifissid; Secholn ":-------------gostation";
							gostationW [0 time]
						)
					)
				)
			)
		|(gomasterW -> if state==RT2501_S_MASTER then
				(
					setleds 0x0000ff;
					Secholn "-------------master";
					startdhcpserver;
//					startconfigserver 80;
					masterW)
			)
		|(masterW -> if !master then
					(
						wifiInit 1;
						resetudp;
						netSetmode IEEE80211_M_MANAGED nil 11;
						nil)
			)
		|(gostationW x-> if state==RT2501_S_CONNECTED then
				(
					Secholn "-------------dhcp";
					if confGetDhcp then startdhcp;
					startdnsclient;
					dhcpW time
				)
			)
		|(dhcpW t-> if netip!=netip_empty then
				(
					Secholn "-------------station";
					stationW
				)
				else if (time-t)>3 then	// retry dhcp client
				(
					startdhcp;
					dhcpW time
				)
			)
		|(reconnectW ->
			netSetmode IEEE80211_M_MANAGED nil 11;
			if wifiAuth then
			(
				Secho confGetWifissid; Secholn ":-------------gostation";
				gostationW [0 time]
			)
		 )
		-> nwifi in
		if nwifi!=nil then set wifi=nwifi;
		set laststate=state
	);
	if retrytime!=time then
	(
		set retrytime=time;
		nettime;
		dnstime;
		0
	)
	;;

fun wifiReady= match wifi with (stationW -> 1)|(_ -> 0);;

fun wifiConnected= match wifi with (stationW -> 1)|(_ -> 0);;


ifdef NOMINAL {
var tab_osc={
	0 0 0 0 0 0 1 1 2 3 3 4 5 6 7 8
	9 10 12 13 15 16 18 19 21 23 25 27 29 31 33 35
	37 39 42 44 46 49 51 54 56 59 62 64 67 70 73 76
	79 81 84 87 90 93 96 99 103 106 109 112 115 118 121 124
};;


fun osc x=
	let (x>>6)&3 -> q in
	let x&255 -> x in
	if q==0 then tab_osc.x
	else if q==1 then 255-tab_osc.(127-x)
	else if q==2 then 255-tab_osc.(x-128)
	else tab_osc.(255-x);;

type Run= configstartRun | configwaitRun _|  pingstartRun |pingwaitRun _ | interactiveReqWaitRun _ |
	rscLoadNextRun | rscLoadWaitRun _ | msgchorRun _ |msgchorstreamRun _ | msgEvalOne _| idlewaitRun | stdWaitRun _ |
	pingRequestWaitRun _ |recordRun |asleepRun | recordStartRun ;;

var run;;
var waitTime=0;; // v19: heure du prochain ping, nil si on prend pingDelay

var pingsrv;;
var broadcasturl;;
var senddata=0;;
var currentTrameID=0;;
var pingdelay=10;;
var recorddelay=4;;

var extleft;;
var extright;;

var gCurrentMessageList;; // the list of messages of the current trame
var msgtimestart;;
var rsctoget;; // list of remaining resources to get for the execution of the current trame
var rscloaded;; // list of resources loaded from current trame
var rsctmp;;	// buffer de chargement des ressources en petits morceaux

// settings, command="IC", managed in eval_IC_msg
var g_streaming_chor_enabled=1;;
var g_cookie="";;
var MASK_BUTTON = 1;;
var MASK_EAR_LEFT = 2;;
var MASK_EAR_RIGHT = 4;;
var g_int_mask=0;;
var g_snd_btn_1 = "clonk";;
var g_snd_btn_2 = "chord";;
var g_record_enabled = 1;;
proto reset_IC 0;;

proto _pingcbhttp 2;;
proto _interactiveReqCBhttp 2;;
proto evalTrame 1;;
proto interactiveFinished 0;;
proto interactiveSendUpload 0;;
proto interactiveStop 0;;
proto interactiveError 0;;
proto interactiveResetEarsTouched 0;;

var gCurrentAudioMsgIndex=-1;;

var BROADCAST_KEYWORD="broadcast";;
var SIGNCUTSIZE=40000;; // taille max du fichier audio de signature

var MSG_IDLE=0x7fffffff;;
var MSG_ASLEEP=0x7ffffffe;;

var STREAMING_PING=60;;
var STD_NET_TIMEOUT=10000;;

var LED_TIMEOUT=600;; // 10 minutes
var CH_frame_duration=1;;
//var CH_set_color=6;;
var CH_set_led_color=7;;
var CH_set_motor=8;;
var CH_set_leds_color=9;; // v16
var CH_set_led_off=10;; // v17
var CH_set_led_palette=14;;
//var CH_set_palette=15;;
var CH_avance=17;;
var CH_ifne=18;;
var CH_attend=19;;
var CH_setmotordir=20;; // v16


// ************************
// Palettes
// ************************

var current_palette = {0 0 0 0 0 0 0 0};;
var current_palette_is_random = 1;; // random par d?faut (pour pallier au fait que les podcasts ne pr?cisent pas de palette)

// 7 palettes
// de 7 couleurs chacune
// Note : il y a un 8eme ?l?ment  chaque fois pour pouvoir faire i&7 et ne pas risquer de planter.
var all_palettes=
{
	{255 12 0 0 255 31 255 242 0 0 3 255 255 242 0 0 255 31 255 12 0 0 0 0} // acidul?e
	{95 0 255 127 0 255 146 0 255 191 0 255 223 0 255 255 0 223 255 0 146 0 0 0} // violet
	{255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0} // lumiere
	{254 128 2 243 68 2 216 6 7 200 4 13 170 0 24 218 5 96 207 6 138 0 0 0} // emotion
	{20 155 18 255 0 0 252 243 5 20 155 18 252 243 5 255 0 0 20 155 18 0 0 0} // oriental
	{252 238 71 206 59 69 85 68 212 78 167 82 243 75 153 151 71 196 255 255 255 0 0 0} // pastel
	{204 255 102 204 255 0 153 255 0 51 204 0 0 153 51 0 136 0 0 102 51 0 0 0} // nature
	{0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} //
};;

// change vraiment la palette
fun set_current_palette p=
	Secho "############set_current_palette ";Iecholn p&7;
	let all_palettes.(p&7) -> p in
	for i=0;i<8 do let i*3 -> j in set current_palette.i=((p.(j))<<16)+((p.(j+1))<<8)+p.(j+2);;

// is mode >= 8 : palette aleatoire. Sinon fix?e  m
fun set_current_palette_mode m=
	if (m >= 8) then
	(
		set current_palette_is_random = 1;
		set_current_palette 0
	)
	else
	(
		set current_palette_is_random = 0;
		set_current_palette m
	);;

fun set_current_palette_color i val=
	Secho "############set_current_palette_color ";Iecho i; Secho " = $";Secholn itoh val;
	set current_palette.i=val;;

// ************************
var midi_acquired=
"\$00";;
var midi_ministop=
"\$00";;
var midi_abort=
"\$00";;
var midi_communion=
"\$00";;
var midi_ack=
"\$00";;
var midi_startInteractive=
"\$00";;
var midi_endInteractive=
"\$00";;
var midi_precedent=
"\$00";;
var midi_suivant=
"\$00";;
var chordef_interactiveerror=
"\$00";;
var chordef_startInteractive=
"\$00";;
var chorstream_chorslist=
"\$00"::"\$00"::"\$00"::"\$00"::nil;;
var midi_endrecord=
"\$00";;
var mp3_startrecord=
"\$00";;

fun controlsound s=
	wavstartlocal s::nil;
	0;;

var buttonlast;;
var buttontime;;
var buttonevent;;
var buttonclicn;;

var BUTTON_CLIC=1;;
var BUTTON_DCLIC=2;;
var BUTTON_LCLIC=3;;
var BUTTON_DLCLIC=4;;
var T_DCLIC=500;;
var T_LCLIC=1500;;


fun buttonloop=
	let button2 -> b in
	if b!=buttonlast then
	(
		set buttonlast=b;
		if b then
		(
			if buttontime==nil then
			(
				set buttonclicn=1;
				set buttontime=time_ms
			)
			else
			(
				set buttonclicn=buttonclicn+1;
				set buttontime=time_ms
			)
		)
		else if buttontime!=nil then set buttontime=time_ms
	)
	else if (buttontime!=nil) then
	(
		if ((time_ms-buttontime)>=T_LCLIC) then
		(
			if buttonlast then set buttonevent=if buttonclicn==1 then BUTTON_LCLIC else BUTTON_DLCLIC;
			set buttontime=nil
		)
		else if ((time_ms-buttontime)>=T_DCLIC)&&!buttonlast then
		(
			set buttonevent=if buttonclicn==1 then BUTTON_CLIC else BUTTON_DCLIC;
			set buttontime=nil
		)
	);;

fun buttongetevent=
	let buttonevent -> ev in
	(
		set buttonevent=nil;
		ev
	);;

proto loop 0;;
fun buttoncheckevent=
	buttonloop;
	if buttonevent!=nil then loop;
	0;;

//var netMac="00904B8C540D";;
fun _webmac key i=
	if i<strlen key then (ctoh strget key i)::_webmac key i+1;;

fun webmac key=strcatlist _webmac key 0;;

fun trameID2Hex t= if t==MSG_IDLE then "7fffffff" else if t==MSG_ASLEEP then "7ffffffe" else itoh t;;

// Pour le developpement,dommenter une des lignes ci-dessous.
// fun confGetServerUrl = "r.nabaztag.com/vl";;
//fun confGetServerUrl = "nabdev.violet.net/vl";; // debug
// fun confGetServerUrl = "192.168.1.11/vl";;

// URLs normales
fun configurl=
  strcatlist confGetServerUrl::"/locate.jsp?sn="::(webmac netMac)::"&h="::(itoa HARDWARE)::nil;;

fun pingurl=
  strcatlist confGetServerUrl::"/p4.jsp?sn="::(webmac netMac)::"&v="::(itoa FIRMWARE)::"&st=1&sd="::(itoh senddata)::"&tc="::(trameID2Hex currentTrameID)::"&h="::(itoa HARDWARE)::nil;;

fun recordurl mode=
  strcatlist confGetServerUrl::"/record.jsp?sn="::(webmac netMac)::"&v="::(itoa FIRMWARE)::"&h="::(itoa HARDWARE)::"&m="::(itoa mode)::nil;;

fun rfidurl tag1=
  strcatlist confGetServerUrl::"/rfid.jsp?sn="::(webmac netMac)::"&v="::(itoa FIRMWARE)::"&h="::(itoa HARDWARE)::"&t[]="::(webmac tag1)::nil;;

fun interactifurl application=
  strcatlist confGetServerUrl::"/itmode.jsp?sn="::(webmac netMac)::"&v="::(itoa FIRMWARE)::"&h="::(itoa HARDWARE)::"&a="::application::nil;;

// Construction des urls d'interactivit?
fun interactifurl_start application= strcatlist (interactifurl application)::"&st=start&tc="::(trameID2Hex currentTrameID)::nil;;
fun interactifurl_btn application position cmdindex btn= strcatlist (interactifurl application)::"&st=btn&pos="::(itoa position)::"&idx="::(itoa cmdindex)::"&btn="::(itoa btn)::g_cookie::nil;;
fun interactifurl_done application = strcatlist (interactifurl application)::"&st=done"::g_cookie::nil;;
fun interactifurl_ear application position cmdindex earg eard = strcatlist (interactifurl application)::"&st=ear&pos="::(itoa position)::"&idx="::(itoa cmdindex)::"&el="::(itoa earg)::"&er="::(itoa eard)::g_cookie::nil;;
fun interactifurl_reco application position cmdindex = strcatlist (interactifurl application)::"&st=reco&pos="::(itoa position)::"&idx="::(itoa cmdindex)::g_cookie::nil;;


fun runinit=
	set run=configstartRun;;


fun filterconfig_word s=
	let strstr s " " 0 -> i in
	if i!=nil then [strsub s 0 i strsub s i+1 nil]
	else [s nil];;

fun filterconfig_line s i=
	let strstr s "\10" i-> j in
	if j!=nil then (filterconfig_word strsub s i j-i)::filterconfig_line s j+1
	else if i<strlen s then (filterconfig_word strsub s i nil)::nil;;

fun filterconfig s i0=
	let strreplace s "\13" "" -> s in
	filterconfig_line s i0;;

fun dumpconfig l=
	Secholn "##dumpconfig :";
	for l=l;l!=nil;tl l do let hd l->[key val] in
	(
		Secho key; Secho " = "; Secholn val
	);
	l;;

fun _configcbhttp http res=
	Secholn "config=";
	let filterconfig Secholn httpgetcontent res 0-> conf in
	(
		set pingsrv=listswitchstr conf "ping";
		set broadcasturl=listswitchstr conf "broad";
		// set broadcasturl = "nabdev.violet.net"; // debug
		if pingsrv!=nil && broadcasturl!=nil then set run=pingstartRun;
		0
	);;

fun runconfigstart=
	if netState==RT2501_S_CONNECTED && wavrunning==0 then set run=configwaitRun httprequest "GET" Secholn configurl nil #_configcbhttp HTTP_NORMAL;
	0;;

fun runconfigwait http=
	// check timeout and retry
	if (httpinactive http)>STD_NET_TIMEOUT then
	(
		Secholn "##timeout on configwait";
		httpabort http;
		set run=configstartRun
	);

	0;;

// Cryptage des trames
fun bintoi3 s x=((strget s x)<<16)+((strget s x+1)<<8)+(strget s x+2);;

fun pingextract_ s i res=
	if i<strlen s then
	let (strget s i)-> code in
	if code==255 then res
	else if code>=0 && code<=10 then
		let bintoi3 s i+1 -> len in
		if len>=0 then pingextract_ s i+4+len [code strsub s i+4 len]::res;;

fun pingextract s=
	if (strget s 0)==0x7f then pingextract_ s 1 nil;;

// replace the prefix string "broadcast" (if present) by broadcasturl
fun rscfilterurl url=
	if 0==strstr url BROADCAST_KEYWORD 0 then strcat broadcasturl strsub url strlen BROADCAST_KEYWORD nil
	else url;;

fun rscfrommsg l=
	if l!=nil then let hd l->[key val] in
	if (!strcmp key "MU") || (!strcmp key "CH") then [val /*nil*/300000]::rscfrommsg tl l
	else if (!strcmp key "MC") then [val SIGNCUTSIZE]::rscfrommsg tl l
	else rscfrommsg tl l;;



var paletteselected = 0;;
// v17 (add romain)
// Fonction permettant d'activer la palette pour le message en cours
// au jour du 31 mai 2007, on recoit le PL apres le son a jouer, la palette associee au son est donc affichee juste apres la fin du message
// Cette fonction passe prealablement sur la trame recue pour mettre la bonne palette
// A noter, si il y a plusieurs palettes dans la trame de retour, seule la premiere est prise en compte
fun CheckForPaletteBefore l=
	for l=l;l!=nil;tl l do let hd l->[key val] in
	(
		if (!strcmp key "PL") && (paletteselected==0) then
		(
			set_current_palette_mode atoi val;
			set paletteselected = 1
		)
	);;

// process incoming messagelist
// messagelist
// returns the corresponding 'run' value
fun msgInitialize messageList=
	Secholn "####################msgInitialize";
	set paletteselected = 0;
	let atoi listswitchstr messageList "ID" -> id in
	(
		Secholn itoh id;
		if id==MSG_IDLE then
		(
			if currentTrameID==MSG_IDLE then
			(
				// continue MSG_IDLE
				earGo 0 extleft 0;
				earGo 1 extright 0;
				stdWaitRun time+pingdelay
			)
			else
			(
				// Was showing messages, becomes IDLE
				// Un tour oreille en violet
				set currentTrameID=MSG_IDLE;
				Secholn "-> idle";
				setleds 0xff00ff;
				earReset;
				idlewaitRun
			)
		)
		else if id==MSG_ASLEEP then
		(
			// Se met en sommeil
			set currentTrameID=MSG_ASLEEP;
			Secholn "-> asleep";
			setleds 0xff00ff;
			earReset;
			asleepRun
		)
		else
		(
			// Really a messageList
			set gCurrentMessageList = messageList;
			set rsctoget=rscfrommsg messageList;
			CheckForPaletteBefore messageList; // Permet de mettre la palette correspondante au message, v17 (add romain)
			// empties the rsc cache
			set rscloaded=nil;
			// run = 'rscLoadNextRun' : will load rsctoget and then start the message 'gCurrentMessageList'
			rscLoadNextRun
		)
	);;

fun msgsStart=
	// Starts playing the messages
	// setleds 0xff0000;

	// Si la palette est definie pour ce message, alors on ne met pas l'aleatoire
	if(paletteselected==0) then
	(
		set current_palette=tabnew 0 8; // v17 : c'?tait invers?
		set_current_palette_mode 8 // random palette par d?faut
	);
	// start evaluating first message
	set currentTrameID=atoi listswitchstr gCurrentMessageList "ID";
	set msgtimestart=time;
	set gCurrentAudioMsgIndex = -1;
	set run=msgEvalOne 0;
	0;;


// ********** loading resources

// callback from rscLoadWaitRun : a resource has been loaded
fun _rscLoadCBhttp http res maxsize=
	if recording then
	(
		httpabort http;
		nil
	)
	else if res!=nil then
	(
		// received a result, store it in rsctmp
		// Je ne comprends pas la logique ici (AS sept07) : a quoi sert rsctmp et maxsize, et comment passe-t-il  la suite ?
//		Secholn res;
		set rsctmp=res::rsctmp;
		if maxsize!=nil && (slistlen rsctmp)>maxsize then
		(
			// too big ? (?)
			httpabort http;
			_rscLoadCBhttp http nil nil
		);
		0
	)
	else
	(
		let hd rsctoget ->[url _] in
		// remember rsc loaded
		set rscloaded=[url tl rev rsctmp nil]::rscloaded;

		// load next rsc
		set rsctoget=tl rsctoget;
		set run=rscLoadNextRun;
		0
	);;

// Recursive : loads all needed resources of the list 'rsctoget' and then starts current message
fun runRscLoadNext=
	let hd rsctoget -> [url maxsize] in
	if url==nil then
	(
		// nothing (else) to load : start execute msgs now
		Secholn "Ready to run !";
		msgsStart;
		0
	)
	else if nil!=listswitchstr rscloaded url then
	(
		// already loaded : load next
		set rsctoget=tl rsctoget;
		runRscLoadNext
	)
	else
	(
		// load resource
		set rsctmp=nil;
		set run=rscLoadWaitRun httprequest "GET" Secholn (rscfilterurl url) nil (fixarg3 #_rscLoadCBhttp maxsize) HTTP_STREAM;
		0
	);;

fun runRscLoadWait http=
	// wait for loading resource
	if (httpinactive http)>STD_NET_TIMEOUT then
	(
		Secholn "##timeout in runRscLoadWait";
		httpabort http;
		// skip, load next
		set rsctoget=tl rsctoget;
		set run=rscLoadNextRun
	);
	0;;


// L'appel du ping
fun callPingRequest aSenddata=
	if (gInteractiveApp == nil) then (
		if aSenddata!=nil then set senddata=aSenddata;
		set run=pingRequestWaitRun httprequest "GET" Secholn pingurl nil #_pingcbhttp HTTP_NORMAL
	);
	0;;

fun runPingRequestWait http=
	// Attente du retour de ping
	// check timeout and retry
	if (httpinactive http)>STD_NET_TIMEOUT then
	(
		Secholn "##timeout on pingsendwait";
		httpabort http;
		callPingRequest nil
	);

	0;;

fun msgEndOfMessages=
	if (gInteractiveApp != nil) then
		// notifier fini
		interactiveFinished
		else
		// demander la suite
		callPingRequest 2;
	0;;

var recordtimestart;;
var recordmode;;
var recorddata;;
var recordreq;;
var recordretry;;
var recordplayend;;

fun uploading = recordreq!=nil;;

fun runrecordstart=
	// wait for the end of the starting sound
	if !wavrunning then
	(
	led 0 0xff0000;//if time_ms&64 then 0xff0000 else 0;
//		setleds 0;
		unforcevol;
		recstart;
		set recordtimestart=time_ms;
		set run=recordRun
	);;

fun _controlrecord mode=
	setleds 0x00;
	wavstop;
	motorset 0 0;
	motorset 1 0;
	forcevol 64;
	wavstartlocalEx mp3_startrecord::nil 100;
	set recordmode=mode;
	set run=recordStartRun;
	0;;

fun _cbrecordhttp http res=
	set recorddata=nil;
	set recordreq=nil;
	Secholn res;
	setleds 0x00;
	if recordplayend!=nil then
	(
		set recordplayend=nil;
		wavstartlocal midi_endrecord::nil
	);
	set run=stdWaitRun time+recorddelay;
	0;;

fun uploadtimeout=
	if uploading then
	(
		if recordplayend!=nil && ((recordplayend-time_ms)<0) then
		(
			set recordplayend=nil;
			wavstartlocal midi_endrecord::nil
		);
		if (httpinactive recordreq)>STD_NET_TIMEOUT then
		(
			Secholn "##timeout on upload";
			httpabort recordreq;
			set recordreq=nil;
			if recordretry>0 then
			(
				// retry
				set recordretry=recordretry-1;
				if (gInteractiveApp == nil) then (
					set recordreq=httprequest "POST" Secholn recordurl recordmode recorddata #_cbrecordhttp HTTP_NORMAL;0
				) else (
					interactiveSendUpload
				);
				nil
			)
			else
			(
				// abort
				set recorddata=nil;
				if (gInteractiveApp == nil) then (
					set run=stdWaitRun time+1;0
				) else (
					interactiveError
				)
			)
		)
	);;

fun runrecord=
//	led 0 if time_ms&1024 then 0xff0000 else 0;
	if !button2 || ((time_ms-recordtimestart)>8000)then
	(
		recstop;
		setleds 0x00;
		let recriff -> wavfile in
		(
			set recorddata=strcatlist wavfile;
			set recordretry=3;
			set recordplayend=time_ms+400;
			if (gInteractiveApp == nil) then (
				set recordreq=httprequest "POST" Secholn recordurl recordmode recorddata #_cbrecordhttp HTTP_NORMAL;
				set run=stdWaitRun time+recorddelay;0
			) else (
				interactiveSendUpload
			)
		)
	);;

// ************************* Choregraphies (TaiChi, .chor) ************
var chordata;;
var chorindex;;
var chortimescale;;
var chornexttime;;
var chorrandom;;
var chortaichimotordir;; // le moteur // v16
var chorendcb=nil;; // the callback to call in the end of the chor
var chor_paused_dur;; // can be paused during buffering
var chor_paused;;
var chor_paused_since;;

fun msgchorstart chor cb i0=
	set chorendcb = cb;
	set chordata=strcatlist chor;
	set chorindex=4+1;	// on saute le header et la première attente
	set chortimescale=0;
	set chornexttime=time_ms;
	set chor_paused_dur = 0;
	set chor_paused_since = nil;
	set chor_paused= 0;
	setleds 0; // shut off all leds at start (or should it be in the chor ?)
	set run=msgchorRun i0;
	0;;

fun msgendchor i0=
	set chornexttime=nil;
	// call the callback
	if (chorendcb != nil) then call chorendcb [i0];
	0;;

fun runmsgchor i0=
	//	Secho "runmsgchor i:";Iecho chorindex; Secho " t:";Iecholn chornexttime;
	// Manage buffering and pauses

	if (!chor_paused && wav_buffering) then (
		// start pause
		set chor_paused_since = time_ms;
		set chor_paused = 1
	) else if (chor_paused && !wav_buffering) then (
		// end pause
		set chor_paused = 0;
		// increment paused_dur
		set chor_paused_dur = chor_paused_dur + (time_ms - chor_paused_since)
	);

	if (!chor_paused) then
	if time_ms-chor_paused_dur >= chornexttime then
	(
		if chorindex>=strlen chordata then msgendchor i0
		else let strget chordata chorindex -> code in
		set chorindex=chorindex+2+
		if code==CH_frame_duration then
		(
			set chortimescale=10*strget chordata chorindex+1;
			1	//nb de paramètres
		)
		else if code==CH_set_motor then
		(
			earGo (strget chordata chorindex+1) (strget chordata chorindex+2) (strget chordata chorindex+3);
			3
		)
		else if code==CH_set_led_color then
		(
//			Secho "set_led_color ";
			//led 4-strget chordata chorindex+1 ((strget chordata chorindex+2)<<16)+((strget chordata chorindex+3)<<8)+(strget chordata chorindex+4); // v16 start
			let 4-strget chordata chorindex+1 -> iled in
			let strget chordata chorindex+2 -> ired in
			let strget chordata chorindex+3 -> igreen in
			let strget chordata chorindex+4 -> iblue in
			(
				//Iecho iled; Secho ",r=";Iecho ired; Secho ",g=";Iecho igreen; Secho ",b=";Iecho iblue; Secholn ".";
				led iled (ired<<16)+(igreen<<8)+iblue
			); // v16 end
			6
		)
		else if code==CH_set_leds_color then // v16 start
		(
			//Secho "set_leds_color ";
			let strget chordata chorindex+1 -> ired in
			let strget chordata chorindex+2 -> igreen in
			let strget chordata chorindex+3 -> iblue in
			let (ired<<16)+(igreen<<8)+iblue -> col in
			(
				//Secho "leds "; Secho ",r=";Iecho ired; Secho ",g=";Iecho igreen; Secho ",b=";Iecho iblue; Secholn ".";
				led 4 col;
				led 3 col;
				led 2 col;
				led 1 col;
				led 0 col
			);
			3
		) // v16 end
		else if code==CH_set_led_palette then
		(
//			Secholn "set_led_palette ";
			led 4-strget chordata chorindex+1 current_palette.(7&strget chordata chorindex+2);
			2
		)
		// v17
		else if code== CH_set_led_off then
		(
			Secholn "CH_set_led_off ";
			led 4-strget chordata chorindex+1 0;
			1
		)
		else if code==CH_avance then
		(
			Secholn "avance";
			let (strget chordata chorindex+1) -> motor in // v16 start
			let (strget chordata chorindex+2) -> delta in
			let chortaichimotordir.motor -> dir in
			earGo motor (earTarget motor)+if dir then -delta else delta dir;
			2
		)
		else if code==CH_setmotordir then
		(
			Secholn "setmotordir";
			let (strget chordata chorindex+1) -> motor in
			let (strget chordata chorindex+2) -> dir in
			set chortaichimotordir=
			if  motor == 0 then {dir chortaichimotordir.1} else {chortaichimotordir.0 dir}; // v16 end
			2
		)
		else if code==CH_ifne then
		(
			Secho "ifne ";Iecholn chorrandom;
			if chorrandom==(Iecholn strget chordata chorindex+1) then 3
			else 3+((strget chordata chorindex+2)<<8)+(strget chordata chorindex+3)
		)
		else if code==CH_attend then
		(
			Secholn "attend";
			if earComplete && wavrunning==0 then 0
			else -2
		)
		else
		(
			msgendchor i0;
			0
		);
		if chornexttime!=nil then
		(
			set chornexttime=chornexttime+(strget chordata chorindex-1)*chortimescale;
			runmsgchor i0
		)
	);;

fun _cbtaichiend unused=
		earDetect;
		if waitTime==0 then
		(
			set run=stdWaitRun time+pingdelay;
			0
		) else (
			set run=stdWaitRun waitTime;
			set waitTime=0;
			0
		)
	;;


// **********************
// Interactivity
// **********************

var gInteractiveLastWavBytes = 0;;

proto _cbContinueStartInteractive 1;;
proto _cbContinueStopInteractive 1;;
proto _cbContinueErrorInteractive 1;;

// Starts interactivity : sets run mode, remember application and request commands
fun interactiveStart application=

	set gInteractiveApp = application;

	reset_IC;

	// oreilles vers l'avant
	(earGo 0 3 0; earGo 1 3 0);

	// jingle
	controlsound midi_startInteractive;
	msgchorstart chordef_startInteractive::nil #_cbContinueStartInteractive nil;

	0;;

fun _cbContinueStartInteractive unused=

	// ask for instructions
	set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_start gInteractiveApp) nil #_interactiveReqCBhttp HTTP_NORMAL);

	// forget currentTrameID so that the next ping does not send it
	set currentTrameID = 0;

	0;;

fun interactiveError=
	// jingle error
	Secho "interactiveError";
	msgchorstart chordef_interactiveerror::nil #_cbContinueErrorInteractive nil;
	0;;

fun _cbContinueErrorInteractive unused=
	interactiveStop;
	0;;

fun interactiveStop=
	// jingle de fin
	controlsound midi_endInteractive;
	msgchorstart chordef_startInteractive::nil #_cbContinueStopInteractive nil;
	0;;

fun _cbContinueStopInteractive unused=
	// finalise stopping : go to ping mode
	// ping mode
	set gInteractiveApp = nil;
	callPingRequest nil;
	0;;

fun interactiveSendBtn btn=
	wavstop;
	earStop;
	let wav_curplayedbytes -> readBytes in ( // controlsound resets wav_curplayedbytes so we cache it
		// sound
		if (btn == BUTTON_CLIC) then (
			if (!strcmp g_snd_btn_1 "clonk") then controlsound midi_abort
			else if (!strcmp g_snd_btn_1"chord") then controlsound midi_ack
			else if (!strcmp g_snd_btn_1 "neutral") then controlsound midi_ministop;
			0
		) else if (btn == BUTTON_DCLIC) then (
			if (!strcmp g_snd_btn_2 "clonk") then controlsound midi_abort
			else if (!strcmp g_snd_btn_2 "chord") then controlsound midi_ack
			else if (!strcmp g_snd_btn_2 "neutral") then controlsound midi_ministop;
			0
		);
		// request instructions
		set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_btn gInteractiveApp readBytes gCurrentAudioMsgIndex btn) nil #_interactiveReqCBhttp HTTP_NORMAL)
	);
	0;;

fun interactiveFinished=
	set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_done gInteractiveApp) nil #_interactiveReqCBhttp HTTP_NORMAL);
	0;;

//*******************
// Ears turned
//*******************
type EarTouch=[num_ET refPos_ET moveDir_ET lastDV_ET lastMoveTime_ET turned_ET];;
var earsTouch;;
var EAR_TOUCH_TIMEOUT=1000;;

fun interactiveResetEarsTouchedrsTouched=
	set earsTouch=tabnew nil 2;
	for i=0;i<2 do set earsTouch.i=[num_ET:i];
	for i=0;i<2 do let earsTouch.i -> et in
	(
		set et.refPos_ET = -1;
		set et.moveDir_ET = -1;
		set et.lastDV_ET = -1;
		set et.lastMoveTime_ET = -1;
		set et.turned_ET = 0
	);
	0;;

fun earDeltaPosNormalized deltaPos=
	// between -EARS_HOLES>>1 and EARS_HOLES>>1
	if (deltaPos > EARS_HOLES>>1) then deltaPos - EARS_HOLES
	else if (deltaPos < -EARS_HOLES>>1) then deltaPos + EARS_HOLES
	else deltaPos;;

fun interactiveNoteEarTouched eari curPos deltaPos=
	// right = 0, left = 1
	if (eari == 0 && (g_int_mask & MASK_EAR_RIGHT == 0)) || (eari == 1 && (g_int_mask & MASK_EAR_LEFT == 0)) then // active
	let earsTouch.eari -> et in
	(
		set et.lastMoveTime_ET = time_ms;
		if (et.refPos_ET == -1) then (
			// first move : remember position and direction of movement
			set et.refPos_ET = curPos;
			if ((earDeltaPosNormalized deltaPos) > 0) then set et.moveDir_ET = 0 else set et.moveDir_ET = 1;
			set et.lastDV_ET = 0

		) else if !et.turned_ET then
		// was already moving and not turned yet : test turned
		let (earDeltaPosNormalized (curPos - et.refPos_ET)) -> normalizedDV in (
			Secho "NDV="; Iecho normalizedDV; Secho ",";

			// Test 1 tour or stopped
			if (et.moveDir_ET == 0 && normalizedDV >= 0 && et.lastDV_ET < 0) then
				// if more than one tour forward : ok
				set et.turned_ET = 1
			else if (et.moveDir_ET == 1 && normalizedDV <= 0 && et.lastDV_ET > 0) then
				// if more than one tour backward : ok
				set et.turned_ET = 1;

			Secho "TOUCH="; Iecho et.turned_ET; Secho ",";

			set et.lastDV_ET = normalizedDV
		)
	);;

fun touchedP i=
	let earsTouch.i -> et in (et.turned_ET || ((et.lastMoveTime_ET != -1) && ((/*Secho "DLAST="; Iecho */(time_ms - et.lastMoveTime_ET))> EAR_TOUCH_TIMEOUT)))
;;

fun interactiveSendEarTouched lefttouch righttouch=
	// right = 0, left = 1
	wavstop;
	earStop;
	let wav_curplayedbytes -> readBytes in  // controlsound resets wav_curplayedbytes so we cache it
	(
		if (lefttouch) then controlsound midi_precedent;
		if (righttouch) then controlsound midi_suivant;
		set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_ear gInteractiveApp readBytes gCurrentAudioMsgIndex righttouch lefttouch) nil #_interactiveReqCBhttp HTTP_NORMAL)
	);
	0;;

fun interactiveEarProcessTouched=
	if (gInteractiveApp != nil) then
	// [AS 24oct07 : il y a surement plus simple  ?crire, mais CAML est un peu bizarre qd mme
	let touchedP 0 -> lefttouch in
	let touchedP 1 -> righttouch in
	if (lefttouch || righttouch) then (
		interactiveSendEarTouched lefttouch righttouch;
		interactiveResetEarsTouched
	);;

fun interactiveSendUpload=
	set recordreq = httprequest "POST" (interactifurl_reco gInteractiveApp gInteractiveLastWavBytes gCurrentAudioMsgIndex) recorddata #_interactiveReqCBhttp HTTP_NORMAL;
	set run=interactiveReqWaitRun recordreq;
	0;;

// Interactive request answer
fun _interactiveReqCBhttp http res=
	Secholn "_interactiveReqCBhttp=";

	if (uploading) then (
		// mode upload / record
		set recorddata=nil;
		set recordreq=nil;
		Secholn res;
		setleds 0x00
	);

	if !recording then
		evalTrame res;

	0;;

// Interactive request wait : timeout
fun runInteractiveReqWait http=
	// Waiting for interactive request
	// check timeout
	if (!uploading) then // upload record mode : timeout managed by uploadtimeout
	if (httpinactive http)>STD_NET_TIMEOUT then
	(
		Secholn "##timeout on runInteractiveReqWait";
		httpabort http;

		// error
		interactiveError
	);

	0;;

// ********************************
// interactive settings
// ********************************

fun reset_IC=
	set g_streaming_chor_enabled=1;
	set g_int_mask=0;
	set g_snd_btn_1 = "clonk";
	set g_snd_btn_2 = "chord";
	set g_record_enabled = 1;
	set g_cookie="";
	0;;

fun eval_IC_msg val=
	// parse val : ickey=icval
	let strstr val "=" 0 -> icpos in
	if icpos != nil && icpos > 0 && icpos < (strlen val) - 1 then
	 // present, not first, not last
		let strsub val 0 icpos -> ickey in
		let strsub val icpos+1 ((strlen val) -1-icpos) -> icval in
		(
			if !strcmp ickey "snd.btn.1" then (
				// snd.btn.1                -> son du bouton en cas de pression courte.
				set g_snd_btn_1 = icval;
				0
			) else if !strcmp ickey "snd.btn.2" then (
				// snd.btn.2                -> son du bouton en cas de double click.
				set g_snd_btn_2 = icval;
				0
			) else if !strcmp ickey "record.enabled" then (
				// record.enabled   -> activation de l'enregistrement
				if (!strcmp icval "true") then set g_record_enabled = 1
				else set g_record_enabled = 0;
				0
			) else if !strcmp ickey "streaming.chor.enabled" then (
				// streaming.chor.enabled   -> chor?graphie de streaming (oreilles)
				if (!strcmp icval "true") then set g_streaming_chor_enabled = 1
				else set g_streaming_chor_enabled = 0;
				0

			) else if !strcmp ickey "int.mask" then (
				// int.mask -> masque d'interruption pour le mode interactif
				set g_int_mask = (atoi icval);
				0

			) else if !strcmp ickey "cookie" then (
				// cookie -> cookie envoy? au serveur
				set g_cookie = strcatlist "&c="::icval::nil;
				0
			) else (
				0
			)
		);;


// ****************************************
// Ex?cution des chor?graphies de streaming
// v17 - AS 25may07

// - 4 pas de danse fournis (dans chorstream_chorslist)
// - une s?quence :
// 	- une fois sur chorst_oreille_chance, bouger les oreilles :
// 		- pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 4, 8, 12 dents) et, si elle est diff?rente de la position courante, y aller, dans le sens 'vers l'avant'.
// 	- tirer un pas de danse au hasard (parmi les 4 fournis)
// 	- tirer un nombre de boucles N au hasard entre 3 et 20 (inclus)
// 	- tirer un frame_duration au hasard entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
// or les pas durent de 44  71 frames, donc le pas dure de 7  17 secs,
// donc la s?quence dure de 21s  5m40s
// 	-> jouer le pas de danse N fois  ce tempo, puis nouvelle s?quence
// A chaque pas de danse : tirer 3 couleurs au hazard dans la palette courante : tete, ventre, pied
// Si palette al?atoire : la changer  toutes les s?quences
// sinon, fix?e par le serveur.
//
var chorst_pasdedanse;;
var chorst_index;;
var chorst_tempo;;
var chorst_loops;;
var chorst_nexttime;;
var chorst_palettecolors = {0 0 0};;

// v17 AS 25may07 : ratio entre changt de s?quence et mvt d'oreille. Plus c'est grand moins souvent les moteurs joueront.
// = 0 :  chaque chgt de seq (en myenne toutes les 2,5 minutes)
// = 1 : une fois sur 2 (soit en moyenne ttes les 5 minutes)
// = 2 : une fois sur 3 (soit en moyenne ttes les 7,5 minutes), etc...
var chorst_oreille_chance;;

// mouvement des leds et oreilles
fun dochorstream=
	if chorst_pasdedanse==nil || ((chorst_index>=strlen chorst_pasdedanse)&&(chorst_loops<1)) then
	(
		// nouvelle s?quence
		// Secho "Sequence suivante ";

		// ears enabled ?
		if (g_streaming_chor_enabled) then
		(
		// movements moteur
		// toutes les chorst_oreille_chance fois en moyenne
		// et aussi la premire fois forc?ment histoire de montrer qu'on commence
		if (chorst_pasdedanse == nil) then
		(
			// une des oreilles en haut, une autre en bas : radio...
			if ((random 2) == 1) then (earGo 0 0 0; earGo 1 10 0) else (earGo 0 10 0; earGo 1 0 0);

			// initialisation chorst_oreille_chance
			set chorst_oreille_chance = 0

		) else if ((random chorst_oreille_chance) == 0) then
		(
			// pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 5, 10, 14 dents) et, si elle est diff?rente de la position courante, y aller, dans le sens 'vers l'avant'.
			let 0::5::10::14::nil -> ear4Positions in
			(
				let listnth ear4Positions rand&3 -> p in earGo 0 p 0;
				let listnth ear4Positions rand&3 -> p in earGo 1 p 0
			);

			// de moins en moins souvent, puis de nouveau souvent, etc..
			if ((set chorst_oreille_chance = chorst_oreille_chance + 1) > 4) then set chorst_oreille_chance = 0
		)
		);

		// choix d'une s?quence = pas de danse (chorst_pasdedanse), tempo et nb de boucles
		set chorst_pasdedanse = listnth chorstream_chorslist Iecholn rand&3;

		set chorst_index=4+1; // on saute le header (4 bytes)
		set chorst_tempo=160+random 90; // entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
		//Secho "tempo "; Iecholn chorst_tempo;
		set chorst_loops=3+random 18; // entre 3 et 20 (inclus)
		//Secho "loops "; Iecholn chorst_loops;

		if (current_palette_is_random) then
			// changer palette courante
			set_current_palette random 7;

		// choisir 3 couleurs au hasard dans la palette
		set chorst_palettecolors={(random 7) (random 7) (random 7)};

		set chorst_nexttime=time_ms

	);

	// continuer  jouer
	while (chorst_index < strlen chorst_pasdedanse) && time_ms >= chorst_nexttime do
	(
		// interprte la choragraphie. Uniquement des set_led_palette et des set_led_off et des set_led_color

		let strget chorst_pasdedanse chorst_index -> cmd in
			// avance l'index de...
			set chorst_index=chorst_index+2+
				if (cmd == CH_set_led_palette) then
				(
					// palette index
					let strget chorst_pasdedanse chorst_index+1 -> iled in
					let strget chorst_pasdedanse chorst_index+2 -> icol in
					let chorst_palettecolors.(3&icol) -> palcol in
						// jouer la LED
						led iled current_palette.palcol;

					// 2 bytes : led, color
					2
				)
				else if (cmd == CH_set_led_off) then
				(
					// off
					let strget chorst_pasdedanse chorst_index+1 -> iled in
						led iled 0;

					// 1 byte : led
					1
				)
				else if (cmd == CH_set_led_color) then
				(
					led strget chorst_pasdedanse chorst_index+1
						((strget chorst_pasdedanse chorst_index+2)<<16) +
						((strget chorst_pasdedanse chorst_index+3)<<8) +
						((strget chorst_pasdedanse chorst_index+4));

						// 6 bytes : 2 qui ne servent  rien
						6
				)
				else if (cmd==CH_frame_duration) then
				(
					// on ne le prend pas en compte : c'est chorst_tempo qui gre le tempo
					// 1 byte : duree
					1
				)

				else (
					// problme : commande inconnue : forcer  recommencer au d?but en incr?mentant beaucoup trop
					Secho "dochorstream : unknown command, restarting dance"; Iecholn cmd;
					strlen chorst_pasdedanse
				);

		// pas de danse fini ?
		if (chorst_index>=strlen chorst_pasdedanse) then
		(
			// on est arriv?s au bout du pas de danse
			// next repeat
			set chorst_loops=chorst_loops-1;
			//Secho "loops "; Iecholn chorst_loops;
			if (chorst_loops > 0) then
			(
				// recommencer pas de danse
				set chorst_index=4+1;  // on saute le header (4 bytes)
				// tout de suite
				set chorst_nexttime=time_ms;

				0 // pour avoir le mme type de return value que les autres branches du if...

			) // sinon on laisse chorst_loops = 0 et chorst_index trop loin, ce qui force un passage  la s?q suivante

		) else
			// date de la prochaine commande
			// note : on repart de time_ms, histoire de se caler sur le temps pr?sent et non pas sur le temps de
			// la chor?graphie, sinon, on a des coups de speed car cette fonction n'est pas toujours appel?e de manire r?gulire.
			let strget chorst_pasdedanse chorst_index-1 -> delay in
				set chorst_nexttime = time_ms+delay*chorst_tempo

	);

	0;;

// Pour savoir si on passe en mode sleep.
// Et aussi pour stopper le son si on reoit un nouveau message (pourquoi ?? [AS nov07])
fun _pingcbstreaming http res lastid=
	Secholn "streaming ping";
	if !recording then
	let nil->msg in
	(
		let pingextract httpgetcontent res -> framelist in
		(
			for l=framelist;l!=nil;tl l do let hd l-> [code val] in
			(
				if code==10 then
				(
					// messages (or IDLE or SLEEP)
					uncrypt val 1 nil 0x47 47;
					set msg=dumpconfig filterconfig val 1;
					0
				);
				0
			)
		);
		if msg!=nil then
		let atoi listswitchstr msg "ID" -> id in
		if id!=currentTrameID && currentTrameID==lastid then
		(
			wavstop;
			0
		)
	);
	0;;

// boucle principale de la chor?graphie de streaming
fun runmsgchorstreaming iTimeTime=
	let iTimeTime->[i0 t0 ping0] in
	if wavrunning==0 then
	(
		// Fin du stream

		// oreilles en haut
		earGo 0 0 0;
		earGo 1 0 0;

		// next message
		set run=msgEvalOne i0+1;

		nil
	)
	else
	(
		// execute streaming choreography
		if !wav_buffering then dochorstream;

		// ping sp?cial toutes les minutes pour v?rifier le sleep
		// don't ping if interactive mode
		if (gInteractiveApp == nil) then
		if (time-ping0)>STREAMING_PING then
		(
			update iTimeTime with [_ _ time];
			httprequest "GET" Secholn pingurl nil (fixarg3 #_pingcbstreaming currentTrameID) HTTP_NORMAL
		);
		0
	);;




//********************************************************
// Executes the i0'th message in the 'gCurrentMessageList' messagelist
// a message is a list [key val]

fun _cbGotoNextMsg i0=
		set run=msgEvalOne i0+1;
		0;;

fun _cbWavError=
	Secho "_cbWavError";
	if (gInteractiveApp != nil) then interactiveError;
	0;;

fun runEvalOneMsg i0=
//	Secho "runEvalOneMsg ";Iecholn i0;
	interactiveResetEarsTouched;

	let listnth gCurrentMessageList i0 -> [key val] in
	if (Secholn key)==nil then
	(
		// tous messages jou?s : demander la suite
		msgEndOfMessages;
		0
	)
	else if (!strcmp key "MU") || (!strcmp key "MC") then
	(
		Secholn "###########Start music";
		set gCurrentAudioMsgIndex=gCurrentAudioMsgIndex+1;
		let listswitchstr rscloaded Secholn val -> music in
			if music==nil then Secholn "###nilmusic";
		wavstartlocal listswitchstr rscloaded val;
		set run=msgEvalOne i0+1;
		0
	)
	else if !strcmp key "ST" then
	(
		Secholn "###########Start streaming music";
		//IPecho netdns 0 1;
		//startdnsclient;
		set gCurrentAudioMsgIndex=gCurrentAudioMsgIndex+1;
		set chorst_pasdedanse=nil;
		let rscfilterurl val -> music in wavstarthttp music #_cbWavError;
		set run=msgchorstreamRun [i0 time time];
		0
	)
	else if !strcmp key "SP" then
	(
		Secholn "###########Start streaming music";
		//IPecho netdns 0 1;
		//startdnsclient;
		set gCurrentAudioMsgIndex=gCurrentAudioMsgIndex+1;
		set chorst_pasdedanse=nil;
		// Romain
		let rscfilterurl val -> music in (
			set music = strcatlist music::"&sn="::(webmac netMac)::nil;
			let music -> tmpval in (
				//set tmpval = md5(strcatlist music::"teloiv"::nil);
				set music = strcatlist music::"&cs="::tmpval::nil
			);
			wavstarthttp music #_cbWavError
		);
		set run=msgchorstreamRun [i0 time time];
		0
	)
	else if !strcmp key "MS" then
	(
		// Music Stream : streams the music (like ST), no choregraphy (assumed to be done by CH), not blocking (like MU)
		set gCurrentAudioMsgIndex=gCurrentAudioMsgIndex+1;
		// starts the streamed music
		let rscfilterurl val -> music in wavstarthttp music #_cbWavError;
		// play next
		set run=msgEvalOne i0+1;

		0
	)
	else if !strcmp key "MW" then
	(
		// wait for the end of music
		if wavrunning==0 then set run=msgEvalOne i0+1;
		0
	)
	else if !strcmp key "CH" then
	(
		msgchorstart (listswitchstr rscloaded val) #_cbGotoNextMsg i0;
		0
	)
	else if !strcmp key "IS" then
	(
		// Start Interactive mode
		interactiveStart val;
		0
	)
	else if !strcmp key "IE" then
	(
		// Ends Interactive mode
		interactiveStop;
		0
	)
	else
	(
		if !strcmp key "PL" then set_current_palette_mode atoi val;
		if !strcmp key "CL" then
				let atoi val -> x in set_current_palette_color (x>>24) x&0xffffff;
		if !strcmp key "IC" then eval_IC_msg val;

		// and skip command
		set run=msgEvalOne i0+1;
		runEvalOneMsg i0+1
	);;

fun runasleep=
	if earReady then
	(
		setleds 0;
		earGo 0 8 0;
		earGo 1 8 0;
		set run=stdWaitRun time+pingdelay;
		0
	);;

// **********************
// Main function : evaluate trame
// trames are sent back from ping and itmode
// a trame contains frames
// a frame can:
// - change the ping delay (type 3)
// - order 'reboot' (type 9)
// - contain new service values and ear positions (type 4)
// - contain messages (type 10)
// In messages frames, messages can contain url resources: resources are loaded and stored and then messages are executed
fun evalTrame res=
	// get trames, list of frames
	let pingextract dump httpgetcontent res -> framelist in
	(
		if framelist==nil then (
			// error, bad trame
			if (gInteractiveApp != nil) then (
				// display error
				interactiveError;
				0
			) else (
				// drop, and ping again later
				set run=stdWaitRun time+pingdelay;
				0
			)
		) else (
			// framelist ok
			set senddata=0;	// acquittement implicite de l'envoi de données
			let nil->messageList in
			(
				for l=framelist;l!=nil;tl l do let hd l-> [code val] in
				(
					// analyse each trame
					Iecho code; Secho " : ";

					// ping delay
					if code==3 then set pingdelay=Iecholn (strget val 0)*1;

					// update sources (services) and ears desired positions
					if code==4 then
					(
						infoUpdate strsub val 4 nil;
						let strget val 20 -> newleft in
						let strget val 21 -> newright in
						(
							if (extleft!=nil) &&((newleft!=extleft) || (newright!=extright)) then
							(
								controlsound midi_communion
							);
							set extleft=newleft;
							set extright=newright
						)
					);

					// messages (or IDLE or SLEEP)
					if code==10 then
					(
						uncrypt val 1 nil 0x47 47;
						set messageList=dumpconfig filterconfig val 1;
						0
					);

					// reboot
					if code==9 then
					(
						reboot 0x0407FE58 0x13fb6754;
						0
					);
					0
				); // for l=framelist

				// post process : message or not ?
				if messageList==nil then
				(
					if currentTrameID==MSG_IDLE then
					(
						earGo 0 extleft 0;
						earGo 1 extright 0;
            set run=stdWaitRun time+pingdelay
					)
					else set run=stdWaitRun time+pingdelay
				) else (
					// messages to process
					set run=msgInitialize messageList
				)
			); // nil->messageList
			0
		) // framelist != nil
	);;


// ******************
// The Ping

// ping processing
fun _pingcbhttp http res=
	Secholn "ping=";
	if !recording then
		evalTrame res;
	0;;

fun runpingstart=
	if (gInteractiveApp == nil) then
	if netState==RT2501_S_CONNECTED then
		set run=pingwaitRun httprequest "GET" Secholn pingurl nil #_pingcbhttp HTTP_NORMAL;
	0;;

// waiting for ping return : manage timeout
fun runpingwait http=
	// check timeout and retry
	if (httpinactive http)>STD_NET_TIMEOUT then
	(
		Secholn "##timeout on pingwait";
		httpabort http;
		// restart later
		set run=stdWaitRun time+pingdelay
	);
	0;;

// main ping loog
fun runStdWait t=
	if time>t then set run=pingstartRun;
	0;;


fun runidlewait=
	// check timeout (oreille bloquée)
	if earReady then
	(
		earDetect;
		setleds 0;
		earGo 0 extleft 0;
		earGo 1 extright 0;
		set run=stdWaitRun time+pingdelay
	);
	0;;

var gWasNetActivity = 0;;

fun noseled=
	if !earDetecting then
	// led tete clignote if netactivity or wav_buffering //
	let uploading || (match run with (rscLoadWaitRun _-> 1)|(pingRequestWaitRun _-> 1)|(interactiveReqWaitRun _->1)|(_->0)) -> netactivity in
	if (netactivity || wav_buffering) then (
		let if netactivity then 256 else if wav_buffering then 128 else 0 -> speed in
		if speed > 0 then led 0 (if time_ms&speed then 0xff0000 else 0);
		set gWasNetActivity = 1
	) else if (gWasNetActivity) then (
		// show off the light
		led 0 0;
		set gWasNetActivity = 0
	);
	0;;

fun bottomled=
	if !earDetecting then
	if ((time-lasthttpevent)>LED_TIMEOUT) then led 4 0xff00ff // bloqu?
	else (let osc time_ms>>4 -> v in led 4 v*0x10001); // pulse violet
	0;;


// ********** RFID **********************
// v19 Amélioration de la lecteure RFID
// v19 Les fonction ParseRfid servent à tester les caractères de l'identifiant RFID
var RFIDchar = 2;; // v19
var RFIDint = 6;; // v19
var RFIDchek = 0;; // v19
var RFIDlast = 0;; // v19

fun _cbrfidhttp http res=
	Secholn res;
	set RFIDchek = 0;
	evalTrame res;
	0;;

fun dumprfid l0=
	for l=l0;l!=nil;tl l do let hd l->x in
	  Secholn webmac x;
	l0;;

fun ParseRfidChar id index= // v19
	set RFIDchar = strget id index;
	RFIDchar;;

fun ParseRfid id = // v19
	set RFIDint = 6;
	for i=0;i<6 do ( if(ParseRfidChar id i) == 0 then set RFIDint = RFIDint - 1);
	RFIDint;;


// *************** CONTROLS *************

fun controlrfid= //v19
	//let hd dumprfid rfidGetList -> rfid in
	if ((time_ms - RFIDlast) > 500) then
  (
	  let rfidGet -> rfid in
	  if rfid!=nil then
	  (
	    set RFIDlast = time_ms;
	    httprequest "GET" rfidurl rfid nil #_cbrfidhttp HTTP_NORMAL
	  )
	);
	0;;

fun controlplay=
	let buttongetevent -> ev in
	if ev!=nil then
	(
		Secholn "controlplay";
		wavstop;
		earStop;
		if ev==BUTTON_CLIC then	(controlsound midi_abort;callPingRequest 5) //pause
		else if ev==BUTTON_DCLIC then (controlsound midi_ack;callPingRequest 1) //ackall
		else if ev==BUTTON_LCLIC then callPingRequest 5 //pause ou record ?
	)
	;;

fun controlwait=
	let buttongetevent -> ev in
	let if ev==nil then eargetevent else ev -> ev in
	if ev!=nil then
	(
		Secholn "controlwait";
		wavstop;
		earStop;
		if ev==BUTTON_CLIC then	callPingRequest 3 //relire
		else if ev==BUTTON_DCLIC then (controlsound midi_ack;callPingRequest 1) //ackall
		else if ev==BUTTON_LCLIC then _controlrecord 0	// callPingRequest 4 //back ou record
		else if ev==BUTTON_DLCLIC then _controlrecord 1	// callPingRequest 4 //back ou record
		else if ev&0x8000 then (controlsound midi_acquired;callPingRequest ev)
	);
	controlrfid
	;;

fun controlinteractif=
	let buttongetevent -> ev in
	if ev!=nil then
	(
		Secholn "controlinteractif";
		if ev==BUTTON_CLIC || ev==BUTTON_DCLIC then	(
			if (g_int_mask&MASK_BUTTON == 0) then interactiveSendBtn ev

		) else if ev==BUTTON_LCLIC then (
			if (g_record_enabled) then (
				// remember wav position and start record
				set gInteractiveLastWavBytes = wav_curplayedbytes ;
				_controlrecord 0
			) else (
				// like BUTTON_CLIC
				set ev = BUTTON_CLIC;
				if (g_int_mask&MASK_BUTTON == 0) then interactiveSendBtn ev
			)
		)
	)
	;;

var CONTROL_WAIT=1;;
var CONTROL_PLAY=2;;

fun loop=
//Secho "l";
	wifiRun;

	if netState==RT2501_S_IDLE then
	match wifi with
	(initW -> nil)
	|(_ ->
		Secholn "######### wifi lost";
		set wifi=reconnectW;
		0
	);

	buttonloop;
//	buttongetevent;
	let match run with
	( configstartRun -> earRun;bottomled;runconfigstart;0 )|
	( configwaitRun http -> earRun;bottomled;runconfigwait http ; 0)|
	( pingstartRun -> earRun;if currentTrameID!=MSG_ASLEEP then bottomled;runpingstart;0)|
	( pingwaitRun http -> earRun; if currentTrameID!=MSG_ASLEEP then (infoRun;bottomled;noseled);runpingwait http;if currentTrameID!=MSG_ASLEEP then CONTROL_WAIT)|
	( pingRequestWaitRun http->bottomled;noseled;runPingRequestWait http;0)|
	( stdWaitRun t -> earRun;if currentTrameID!=MSG_ASLEEP then (infoRun;bottomled;noseled);runStdWait t; CONTROL_WAIT) |
	( rscLoadNextRun -> earRun;infoRun;bottomled;noseled;runRscLoadNext; CONTROL_WAIT)|
	( rscLoadWaitRun http-> earRun;infoRun;bottomled;noseled;runRscLoadWait http;CONTROL_WAIT)|
	( msgEvalOne i-> earRun;runEvalOneMsg i;CONTROL_PLAY)|
	( msgchorRun i-> earRun;noseled;runmsgchor i;CONTROL_PLAY)|
	( msgchorstreamRun iTimeTime-> earRun;noseled;runmsgchorstreaming iTimeTime;CONTROL_PLAY)|
	( idlewaitRun -> earRun;runidlewait;CONTROL_WAIT)|
	( recordRun -> runrecord; 0)|
	( asleepRun ->earRun;runasleep;0) |
	( recordStartRun -> runrecordstart; 0) |
	( interactiveReqWaitRun http-> earRun;infoRun;bottomled;noseled;runInteractiveReqWait http;CONTROL_WAIT) |
	(_->0) -> keymanager in
	if keymanager==CONTROL_WAIT then controlwait
	else if keymanager==CONTROL_PLAY then (if (gInteractiveApp == nil) then controlplay else controlinteractif)
	else buttongetevent;
	uploadtimeout;

	// if ears touched while interactive : process it
	interactiveEarProcessTouched;

  //Iecholn netRssi;
  //Secholn ":loop";

	wavtime;


	updatevol;
	0;;

fun main=
	MACecho netMac 0 1;
	set master=0;
	Secholn ":started";

	confInit;
	wifiInit 0;
	loopcb	#loop;
	
	infoInit;
	netstart;
	startdnsclient;
	Secholn ":done";

	srand time_ms;
	//updatevol;
  //wavstartlocal midi_endrecord::nil;
	dumpscan wifiscans;
	runinit;
	0;;

}